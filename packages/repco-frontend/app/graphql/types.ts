/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
export type Maybe<T> = T | null
export type InputMaybe<T> = T | null | undefined
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: string
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: any
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any
}

export type Agent = {
  /** Reads and enables pagination through a set of `Commit`. */
  commits: CommitsConnection
  /** Reads and enables pagination through a set of `Commit`. */
  commitsByCommitAgentDidAndParent: AgentCommitsByCommitAgentDidAndParentManyToManyConnection
  did: Scalars['String']
  /** Reads and enables pagination through a set of `Repo`. */
  reposByCommitAgentDidAndRepoDid: AgentReposByCommitAgentDidAndRepoDidManyToManyConnection
  /** Reads and enables pagination through a set of `Revision`. */
  revisions: RevisionsConnection
  type?: Maybe<AgentType>
  /** Reads a single `User` that is related to this `Agent`. */
  userByDid?: Maybe<User>
  /**
   * Reads and enables pagination through a set of `User`.
   * @deprecated Please use userByDid instead
   */
  usersBy: UsersConnection
}

export type AgentCommitsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

export type AgentCommitsByCommitAgentDidAndParentArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

export type AgentReposByCommitAgentDidAndRepoDidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<RepoCondition>
  filter: InputMaybe<RepoFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ReposOrderBy>>
}

export type AgentRevisionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<RevisionCondition>
  filter: InputMaybe<RevisionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<RevisionsOrderBy>>
}

export type AgentUsersByArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<UserCondition>
  filter: InputMaybe<UserFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<UsersOrderBy>>
}

/** A connection to a list of `Commit` values, with data from `Commit`. */
export type AgentCommitsByCommitAgentDidAndParentManyToManyConnection = {
  /** A list of edges which contains the `Commit`, info from the `Commit`, and the cursor to aid in pagination. */
  edges: Array<AgentCommitsByCommitAgentDidAndParentManyToManyEdge>
  /** A list of `Commit` objects. */
  nodes: Array<Commit>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Commit` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Commit` edge in the connection, with data from `Commit`. */
export type AgentCommitsByCommitAgentDidAndParentManyToManyEdge = {
  /** Reads and enables pagination through a set of `Commit`. */
  commitsByParent: CommitsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Commit` at the end of the edge. */
  node: Commit
}

/** A `Commit` edge in the connection, with data from `Commit`. */
export type AgentCommitsByCommitAgentDidAndParentManyToManyEdgeCommitsByParentArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<CommitCondition>
    filter: InputMaybe<CommitFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<CommitsOrderBy>>
  }

/** A condition to be used against `Agent` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AgentCondition = {
  /** Checks for equality with the object’s `did` field. */
  did?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<AgentType>
}

/** A filter to be used against `Agent` object types. All fields are combined with a logical ‘and.’ */
export type AgentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AgentFilter>>
  /** Filter by the object’s `commits` relation. */
  commits?: InputMaybe<AgentToManyCommitFilter>
  /** Some related `commits` exist. */
  commitsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `did` field. */
  did?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<AgentFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AgentFilter>>
  /** Filter by the object’s `revisions` relation. */
  revisions?: InputMaybe<AgentToManyRevisionFilter>
  /** Some related `revisions` exist. */
  revisionsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<AgentTypeFilter>
  /** Filter by the object’s `userByDid` relation. */
  userByDid?: InputMaybe<UserFilter>
  /** A related `userByDid` exists. */
  userByDidExists?: InputMaybe<Scalars['Boolean']>
}

/** A connection to a list of `Repo` values, with data from `Commit`. */
export type AgentReposByCommitAgentDidAndRepoDidManyToManyConnection = {
  /** A list of edges which contains the `Repo`, info from the `Commit`, and the cursor to aid in pagination. */
  edges: Array<AgentReposByCommitAgentDidAndRepoDidManyToManyEdge>
  /** A list of `Repo` objects. */
  nodes: Array<Repo>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Repo` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Repo` edge in the connection, with data from `Commit`. */
export type AgentReposByCommitAgentDidAndRepoDidManyToManyEdge = {
  /** Reads and enables pagination through a set of `Commit`. */
  commits: CommitsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Repo` at the end of the edge. */
  node: Repo
}

/** A `Repo` edge in the connection, with data from `Commit`. */
export type AgentReposByCommitAgentDidAndRepoDidManyToManyEdgeCommitsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

/** A filter to be used against many `Commit` object types. All fields are combined with a logical ‘and.’ */
export type AgentToManyCommitFilter = {
  /** Every related `Commit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CommitFilter>
  /** No related `Commit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CommitFilter>
  /** Some related `Commit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CommitFilter>
}

/** A filter to be used against many `Revision` object types. All fields are combined with a logical ‘and.’ */
export type AgentToManyRevisionFilter = {
  /** Every related `Revision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RevisionFilter>
  /** No related `Revision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RevisionFilter>
  /** Some related `Revision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RevisionFilter>
}

export enum AgentType {
  Datasource = 'DATASOURCE',
  User = 'USER',
}

/** A filter to be used against AgentType fields. All fields are combined with a logical ‘and.’ */
export type AgentTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<AgentType>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<AgentType>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<AgentType>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<AgentType>
  /** Included in the specified list. */
  in?: InputMaybe<Array<AgentType>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<AgentType>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<AgentType>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<AgentType>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<AgentType>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<AgentType>>
}

/** A connection to a list of `Agent` values. */
export type AgentsConnection = {
  /** A list of edges which contains the `Agent` and cursor to aid in pagination. */
  edges: Array<AgentsEdge>
  /** A list of `Agent` objects. */
  nodes: Array<Agent>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Agent` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Agent` edge in the connection. */
export type AgentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Agent` at the end of the edge. */
  node: Agent
}

/** Methods to use when ordering `Agent`. */
export enum AgentsOrderBy {
  DidAsc = 'DID_ASC',
  DidDesc = 'DID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
}

export type Block = {
  bytes: Scalars['String']
  cid: Scalars['String']
}

/** A condition to be used against `Block` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type BlockCondition = {
  /** Checks for equality with the object’s `bytes` field. */
  bytes?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `cid` field. */
  cid?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Block` object types. All fields are combined with a logical ‘and.’ */
export type BlockFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BlockFilter>>
  /** Filter by the object’s `cid` field. */
  cid?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<BlockFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BlockFilter>>
}

/** A connection to a list of `Block` values. */
export type BlocksConnection = {
  /** A list of edges which contains the `Block` and cursor to aid in pagination. */
  edges: Array<BlocksEdge>
  /** A list of `Block` objects. */
  nodes: Array<Block>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Block` edge in the connection. */
export type BlocksEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Block` at the end of the edge. */
  node: Block
}

/** Methods to use when ordering `Block`. */
export enum BlocksOrderBy {
  BytesAsc = 'BYTES_ASC',
  BytesDesc = 'BYTES_DESC',
  CidAsc = 'CID_ASC',
  CidDesc = 'CID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']>>
}

export type BroadcastEvent = {
  /** Reads a single `PublicationService` that is related to this `BroadcastEvent`. */
  broadcastService?: Maybe<PublicationService>
  broadcastServiceUid: Scalars['String']
  /** Reads a single `ContentItem` that is related to this `BroadcastEvent`. */
  contentItem?: Maybe<ContentItem>
  contentItemUid: Scalars['String']
  duration: Scalars['Float']
  /** Reads a single `Revision` that is related to this `BroadcastEvent`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  start: Scalars['Float']
  uid: Scalars['String']
}

/**
 * A condition to be used against `BroadcastEvent` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type BroadcastEventCondition = {
  /** Checks for equality with the object’s `broadcastServiceUid` field. */
  broadcastServiceUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `contentItemUid` field. */
  contentItemUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `duration` field. */
  duration?: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `start` field. */
  start?: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `BroadcastEvent` object types. All fields are combined with a logical ‘and.’ */
export type BroadcastEventFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BroadcastEventFilter>>
  /** Filter by the object’s `broadcastService` relation. */
  broadcastService?: InputMaybe<PublicationServiceFilter>
  /** Filter by the object’s `broadcastServiceUid` field. */
  broadcastServiceUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `contentItem` relation. */
  contentItem?: InputMaybe<ContentItemFilter>
  /** Filter by the object’s `contentItemUid` field. */
  contentItemUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `duration` field. */
  duration?: InputMaybe<FloatFilter>
  /** Negates the expression. */
  not?: InputMaybe<BroadcastEventFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BroadcastEventFilter>>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `start` field. */
  start?: InputMaybe<FloatFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `BroadcastEvent` values. */
export type BroadcastEventsConnection = {
  /** A list of edges which contains the `BroadcastEvent` and cursor to aid in pagination. */
  edges: Array<BroadcastEventsEdge>
  /** A list of `BroadcastEvent` objects. */
  nodes: Array<BroadcastEvent>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `BroadcastEvent` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `BroadcastEvent` edge in the connection. */
export type BroadcastEventsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `BroadcastEvent` at the end of the edge. */
  node: BroadcastEvent
}

/** Methods to use when ordering `BroadcastEvent`. */
export enum BroadcastEventsOrderBy {
  BroadcastServiceUidAsc = 'BROADCAST_SERVICE_UID_ASC',
  BroadcastServiceUidDesc = 'BROADCAST_SERVICE_UID_DESC',
  ContentItemUidAsc = 'CONTENT_ITEM_UID_ASC',
  ContentItemUidDesc = 'CONTENT_ITEM_UID_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Chapter = {
  duration: Scalars['Float']
  /** Reads a single `MediaAsset` that is related to this `Chapter`. */
  mediaAsset?: Maybe<MediaAsset>
  mediaAssetUid: Scalars['String']
  /** Reads a single `Revision` that is related to this `Chapter`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  start: Scalars['Float']
  title: Scalars['String']
  type: Scalars['String']
  uid: Scalars['String']
}

/** A condition to be used against `Chapter` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ChapterCondition = {
  /** Checks for equality with the object’s `duration` field. */
  duration?: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `mediaAssetUid` field. */
  mediaAssetUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `start` field. */
  start?: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Chapter` object types. All fields are combined with a logical ‘and.’ */
export type ChapterFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ChapterFilter>>
  /** Filter by the object’s `duration` field. */
  duration?: InputMaybe<FloatFilter>
  /** Filter by the object’s `mediaAsset` relation. */
  mediaAsset?: InputMaybe<MediaAssetFilter>
  /** Filter by the object’s `mediaAssetUid` field. */
  mediaAssetUid?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<ChapterFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ChapterFilter>>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `start` field. */
  start?: InputMaybe<FloatFilter>
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `Chapter` values. */
export type ChaptersConnection = {
  /** A list of edges which contains the `Chapter` and cursor to aid in pagination. */
  edges: Array<ChaptersEdge>
  /** A list of `Chapter` objects. */
  nodes: Array<Chapter>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Chapter` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Chapter` edge in the connection. */
export type ChaptersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Chapter` at the end of the edge. */
  node: Chapter
}

/** Methods to use when ordering `Chapter`. */
export enum ChaptersOrderBy {
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  MediaAssetUidAsc = 'MEDIA_ASSET_UID_ASC',
  MediaAssetUidDesc = 'MEDIA_ASSET_UID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Commit = {
  /** Reads a single `Agent` that is related to this `Commit`. */
  agent?: Maybe<Agent>
  agentDid: Scalars['String']
  /** Reads and enables pagination through a set of `Agent`. */
  agentsByCommitParentAndAgentDid: CommitAgentsByCommitParentAndAgentDidManyToManyConnection
  /** Reads a single `Commit` that is related to this `Commit`. */
  commitByParent?: Maybe<Commit>
  commitCid: Scalars['String']
  /** Reads and enables pagination through a set of `Commit`. */
  commitsByParent: CommitsConnection
  parent?: Maybe<Scalars['String']>
  /** Reads a single `Repo` that is related to this `Commit`. */
  repo?: Maybe<Repo>
  repoDid: Scalars['String']
  /** Reads and enables pagination through a set of `Repo`. */
  reposByCommitParentAndRepoDid: CommitReposByCommitParentAndRepoDidManyToManyConnection
  /** Reads and enables pagination through a set of `Repo`. */
  reposByHead: ReposConnection
  rootCid: Scalars['String']
  timestamp: Scalars['Datetime']
}

export type CommitAgentsByCommitParentAndAgentDidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<AgentCondition>
  filter: InputMaybe<AgentFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<AgentsOrderBy>>
}

export type CommitCommitsByParentArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

export type CommitReposByCommitParentAndRepoDidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<RepoCondition>
  filter: InputMaybe<RepoFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ReposOrderBy>>
}

export type CommitReposByHeadArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<RepoCondition>
  filter: InputMaybe<RepoFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ReposOrderBy>>
}

/** A connection to a list of `Agent` values, with data from `Commit`. */
export type CommitAgentsByCommitParentAndAgentDidManyToManyConnection = {
  /** A list of edges which contains the `Agent`, info from the `Commit`, and the cursor to aid in pagination. */
  edges: Array<CommitAgentsByCommitParentAndAgentDidManyToManyEdge>
  /** A list of `Agent` objects. */
  nodes: Array<Agent>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Agent` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Agent` edge in the connection, with data from `Commit`. */
export type CommitAgentsByCommitParentAndAgentDidManyToManyEdge = {
  /** Reads and enables pagination through a set of `Commit`. */
  commits: CommitsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Agent` at the end of the edge. */
  node: Agent
}

/** A `Agent` edge in the connection, with data from `Commit`. */
export type CommitAgentsByCommitParentAndAgentDidManyToManyEdgeCommitsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

/** A condition to be used against `Commit` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CommitCondition = {
  /** Checks for equality with the object’s `agentDid` field. */
  agentDid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `commitCid` field. */
  commitCid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `parent` field. */
  parent?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `repoDid` field. */
  repoDid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `rootCid` field. */
  rootCid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']>
}

/** A filter to be used against `Commit` object types. All fields are combined with a logical ‘and.’ */
export type CommitFilter = {
  /** Filter by the object’s `agent` relation. */
  agent?: InputMaybe<AgentFilter>
  /** Filter by the object’s `agentDid` field. */
  agentDid?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CommitFilter>>
  /** Filter by the object’s `commitByParent` relation. */
  commitByParent?: InputMaybe<CommitFilter>
  /** A related `commitByParent` exists. */
  commitByParentExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `commitCid` field. */
  commitCid?: InputMaybe<StringFilter>
  /** Filter by the object’s `commitsByParent` relation. */
  commitsByParent?: InputMaybe<CommitToManyCommitFilter>
  /** Some related `commitsByParent` exist. */
  commitsByParentExist?: InputMaybe<Scalars['Boolean']>
  /** Negates the expression. */
  not?: InputMaybe<CommitFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CommitFilter>>
  /** Filter by the object’s `parent` field. */
  parent?: InputMaybe<StringFilter>
  /** Filter by the object’s `repo` relation. */
  repo?: InputMaybe<RepoFilter>
  /** Filter by the object’s `repoDid` field. */
  repoDid?: InputMaybe<StringFilter>
  /** Filter by the object’s `reposByHead` relation. */
  reposByHead?: InputMaybe<CommitToManyRepoFilter>
  /** Some related `reposByHead` exist. */
  reposByHeadExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `rootCid` field. */
  rootCid?: InputMaybe<StringFilter>
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>
}

/** A connection to a list of `Repo` values, with data from `Commit`. */
export type CommitReposByCommitParentAndRepoDidManyToManyConnection = {
  /** A list of edges which contains the `Repo`, info from the `Commit`, and the cursor to aid in pagination. */
  edges: Array<CommitReposByCommitParentAndRepoDidManyToManyEdge>
  /** A list of `Repo` objects. */
  nodes: Array<Repo>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Repo` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Repo` edge in the connection, with data from `Commit`. */
export type CommitReposByCommitParentAndRepoDidManyToManyEdge = {
  /** Reads and enables pagination through a set of `Commit`. */
  commits: CommitsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Repo` at the end of the edge. */
  node: Repo
}

/** A `Repo` edge in the connection, with data from `Commit`. */
export type CommitReposByCommitParentAndRepoDidManyToManyEdgeCommitsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

/** A filter to be used against many `Commit` object types. All fields are combined with a logical ‘and.’ */
export type CommitToManyCommitFilter = {
  /** Every related `Commit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CommitFilter>
  /** No related `Commit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CommitFilter>
  /** Some related `Commit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CommitFilter>
}

/** A filter to be used against many `Repo` object types. All fields are combined with a logical ‘and.’ */
export type CommitToManyRepoFilter = {
  /** Every related `Repo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RepoFilter>
  /** No related `Repo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RepoFilter>
  /** Some related `Repo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RepoFilter>
}

/** A connection to a list of `Commit` values. */
export type CommitsConnection = {
  /** A list of edges which contains the `Commit` and cursor to aid in pagination. */
  edges: Array<CommitsEdge>
  /** A list of `Commit` objects. */
  nodes: Array<Commit>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Commit` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Commit` edge in the connection. */
export type CommitsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Commit` at the end of the edge. */
  node: Commit
}

/** Methods to use when ordering `Commit`. */
export enum CommitsOrderBy {
  AgentDidAsc = 'AGENT_DID_ASC',
  AgentDidDesc = 'AGENT_DID_DESC',
  CommitCidAsc = 'COMMIT_CID_ASC',
  CommitCidDesc = 'COMMIT_CID_DESC',
  Natural = 'NATURAL',
  ParentAsc = 'PARENT_ASC',
  ParentDesc = 'PARENT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RepoDidAsc = 'REPO_DID_ASC',
  RepoDidDesc = 'REPO_DID_DESC',
  RootCidAsc = 'ROOT_CID_ASC',
  RootCidDesc = 'ROOT_CID_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
}

export type Concept = {
  /** Reads and enables pagination through a set of `Concept`. */
  childConcepts: ConceptsConnection
  /** Reads and enables pagination through a set of `Concept`. */
  conceptsByConceptParentUidAndSameAsUid: ConceptConceptsByConceptParentUidAndSameAsUidManyToManyConnection
  /** Reads and enables pagination through a set of `Concept`. */
  conceptsByConceptSameAsUidAndParentUid: ConceptConceptsByConceptSameAsUidAndParentUidManyToManyConnection
  /** Reads and enables pagination through a set of `Concept`. */
  conceptsBySameAs: ConceptsConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ConceptContentItemsByConceptToContentItemAAndBManyToManyConnection
  description?: Maybe<Scalars['String']>
  kind: ConceptKind
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: ConceptMediaAssetsByConceptToMediaAssetAAndBManyToManyConnection
  name: Scalars['String']
  originNamespace?: Maybe<Scalars['String']>
  /** Reads a single `Concept` that is related to this `Concept`. */
  parent?: Maybe<Concept>
  parentUid?: Maybe<Scalars['String']>
  /** Reads a single `Revision` that is related to this `Concept`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  /** Reads a single `Concept` that is related to this `Concept`. */
  sameAs?: Maybe<Concept>
  sameAsUid?: Maybe<Scalars['String']>
  summary?: Maybe<Scalars['String']>
  uid: Scalars['String']
  wikidataIdentifier?: Maybe<Scalars['String']>
}

export type ConceptChildConceptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type ConceptConceptsByConceptParentUidAndSameAsUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type ConceptConceptsByConceptSameAsUidAndParentUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type ConceptConceptsBySameAsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type ConceptContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type ConceptMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

/** A connection to a list of `Concept` values, with data from `Concept`. */
export type ConceptConceptsByConceptParentUidAndSameAsUidManyToManyConnection =
  {
    /** A list of edges which contains the `Concept`, info from the `Concept`, and the cursor to aid in pagination. */
    edges: Array<ConceptConceptsByConceptParentUidAndSameAsUidManyToManyEdge>
    /** A list of `Concept` objects. */
    nodes: Array<Concept>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Concept` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Concept` edge in the connection, with data from `Concept`. */
export type ConceptConceptsByConceptParentUidAndSameAsUidManyToManyEdge = {
  /** Reads and enables pagination through a set of `Concept`. */
  conceptsBySameAs: ConceptsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Concept` at the end of the edge. */
  node: Concept
}

/** A `Concept` edge in the connection, with data from `Concept`. */
export type ConceptConceptsByConceptParentUidAndSameAsUidManyToManyEdgeConceptsBySameAsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ConceptCondition>
    filter: InputMaybe<ConceptFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ConceptsOrderBy>>
  }

/** A connection to a list of `Concept` values, with data from `Concept`. */
export type ConceptConceptsByConceptSameAsUidAndParentUidManyToManyConnection =
  {
    /** A list of edges which contains the `Concept`, info from the `Concept`, and the cursor to aid in pagination. */
    edges: Array<ConceptConceptsByConceptSameAsUidAndParentUidManyToManyEdge>
    /** A list of `Concept` objects. */
    nodes: Array<Concept>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Concept` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Concept` edge in the connection, with data from `Concept`. */
export type ConceptConceptsByConceptSameAsUidAndParentUidManyToManyEdge = {
  /** Reads and enables pagination through a set of `Concept`. */
  childConcepts: ConceptsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Concept` at the end of the edge. */
  node: Concept
}

/** A `Concept` edge in the connection, with data from `Concept`. */
export type ConceptConceptsByConceptSameAsUidAndParentUidManyToManyEdgeChildConceptsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ConceptCondition>
    filter: InputMaybe<ConceptFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ConceptsOrderBy>>
  }

/** A condition to be used against `Concept` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ConceptCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `kind` field. */
  kind?: InputMaybe<ConceptKind>
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `originNamespace` field. */
  originNamespace?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `parentUid` field. */
  parentUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `sameAsUid` field. */
  sameAsUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `wikidataIdentifier` field. */
  wikidataIdentifier?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentItem` values, with data from `_ConceptToContentItem`. */
export type ConceptContentItemsByConceptToContentItemAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `_ConceptToContentItem`, and the cursor to aid in pagination. */
    edges: Array<ConceptContentItemsByConceptToContentItemAAndBManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `_ConceptToContentItem`. */
export type ConceptContentItemsByConceptToContentItemAAndBManyToManyEdge = {
  /** Reads and enables pagination through a set of `_ConceptToContentItem`. */
  _conceptToContentItemsByB: _ConceptToContentItemsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `ContentItem` at the end of the edge. */
  node: ContentItem
}

/** A `ContentItem` edge in the connection, with data from `_ConceptToContentItem`. */
export type ConceptContentItemsByConceptToContentItemAAndBManyToManyEdge_ConceptToContentItemsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ConceptToContentItemCondition>
    filter: InputMaybe<_ConceptToContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ConceptToContentItemsOrderBy>>
  }

/** A filter to be used against `Concept` object types. All fields are combined with a logical ‘and.’ */
export type ConceptFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ConceptFilter>>
  /** Filter by the object’s `childConcepts` relation. */
  childConcepts?: InputMaybe<ConceptToManyConceptFilter>
  /** Some related `childConcepts` exist. */
  childConceptsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `conceptsBySameAs` relation. */
  conceptsBySameAs?: InputMaybe<ConceptToManyConceptFilter>
  /** Some related `conceptsBySameAs` exist. */
  conceptsBySameAsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>
  /** Filter by the object’s `kind` field. */
  kind?: InputMaybe<ConceptKindFilter>
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<ConceptFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ConceptFilter>>
  /** Filter by the object’s `originNamespace` field. */
  originNamespace?: InputMaybe<StringFilter>
  /** Filter by the object’s `parent` relation. */
  parent?: InputMaybe<ConceptFilter>
  /** A related `parent` exists. */
  parentExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `parentUid` field. */
  parentUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `sameAs` relation. */
  sameAs?: InputMaybe<ConceptFilter>
  /** A related `sameAs` exists. */
  sameAsExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `sameAsUid` field. */
  sameAsUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
  /** Filter by the object’s `wikidataIdentifier` field. */
  wikidataIdentifier?: InputMaybe<StringFilter>
}

export enum ConceptKind {
  Category = 'CATEGORY',
  Tag = 'TAG',
}

/** A filter to be used against ConceptKind fields. All fields are combined with a logical ‘and.’ */
export type ConceptKindFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ConceptKind>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ConceptKind>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ConceptKind>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ConceptKind>
  /** Included in the specified list. */
  in?: InputMaybe<Array<ConceptKind>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<ConceptKind>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ConceptKind>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ConceptKind>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ConceptKind>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ConceptKind>>
}

/** A connection to a list of `MediaAsset` values, with data from `_ConceptToMediaAsset`. */
export type ConceptMediaAssetsByConceptToMediaAssetAAndBManyToManyConnection = {
  /** A list of edges which contains the `MediaAsset`, info from the `_ConceptToMediaAsset`, and the cursor to aid in pagination. */
  edges: Array<ConceptMediaAssetsByConceptToMediaAssetAAndBManyToManyEdge>
  /** A list of `MediaAsset` objects. */
  nodes: Array<MediaAsset>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `MediaAsset` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `MediaAsset` edge in the connection, with data from `_ConceptToMediaAsset`. */
export type ConceptMediaAssetsByConceptToMediaAssetAAndBManyToManyEdge = {
  /** Reads and enables pagination through a set of `_ConceptToMediaAsset`. */
  _conceptToMediaAssetsByB: _ConceptToMediaAssetsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `MediaAsset` at the end of the edge. */
  node: MediaAsset
}

/** A `MediaAsset` edge in the connection, with data from `_ConceptToMediaAsset`. */
export type ConceptMediaAssetsByConceptToMediaAssetAAndBManyToManyEdge_ConceptToMediaAssetsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ConceptToMediaAssetCondition>
    filter: InputMaybe<_ConceptToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ConceptToMediaAssetsOrderBy>>
  }

/** A filter to be used against many `Concept` object types. All fields are combined with a logical ‘and.’ */
export type ConceptToManyConceptFilter = {
  /** Every related `Concept` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ConceptFilter>
  /** No related `Concept` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ConceptFilter>
  /** Some related `Concept` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ConceptFilter>
}

/** A connection to a list of `Concept` values. */
export type ConceptsConnection = {
  /** A list of edges which contains the `Concept` and cursor to aid in pagination. */
  edges: Array<ConceptsEdge>
  /** A list of `Concept` objects. */
  nodes: Array<Concept>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Concept` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Concept` edge in the connection. */
export type ConceptsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Concept` at the end of the edge. */
  node: Concept
}

/** Methods to use when ordering `Concept`. */
export enum ConceptsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  KindAsc = 'KIND_ASC',
  KindDesc = 'KIND_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OriginNamespaceAsc = 'ORIGIN_NAMESPACE_ASC',
  OriginNamespaceDesc = 'ORIGIN_NAMESPACE_DESC',
  ParentUidAsc = 'PARENT_UID_ASC',
  ParentUidDesc = 'PARENT_UID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  SameAsUidAsc = 'SAME_AS_UID_ASC',
  SameAsUidDesc = 'SAME_AS_UID_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
  WikidataIdentifierAsc = 'WIKIDATA_IDENTIFIER_ASC',
  WikidataIdentifierDesc = 'WIKIDATA_IDENTIFIER_DESC',
}

export type ContentGrouping = {
  broadcastSchedule?: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ContentGroupingContentItemsByContentGroupingToContentItemAAndBManyToManyConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItemsByPrimaryGrouping: ContentItemsConnection
  description?: Maybe<Scalars['String']>
  groupingType: Scalars['String']
  /** Reads a single `License` that is related to this `ContentGrouping`. */
  license?: Maybe<License>
  licenseUid?: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `License`. */
  licensesByContentItemPrimaryGroupingUidAndLicenseUid: ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `PublicationService`. */
  publicationServicesByContentItemPrimaryGroupingUidAndPublicationServiceUid: ContentGroupingPublicationServicesByContentItemPrimaryGroupingUidAndPublicationServiceUidManyToManyConnection
  /** Reads a single `Revision` that is related to this `ContentGrouping`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  startingDate?: Maybe<Scalars['Datetime']>
  subtitle?: Maybe<Scalars['String']>
  summary?: Maybe<Scalars['String']>
  terminationDate?: Maybe<Scalars['Datetime']>
  title: Scalars['String']
  uid: Scalars['String']
  variant: ContentGroupingVariant
}

export type ContentGroupingContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type ContentGroupingContentItemsByPrimaryGroupingArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<LicenseCondition>
    filter: InputMaybe<LicenseFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<LicensesOrderBy>>
  }

export type ContentGroupingPublicationServicesByContentItemPrimaryGroupingUidAndPublicationServiceUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<PublicationServiceCondition>
    filter: InputMaybe<PublicationServiceFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<PublicationServicesOrderBy>>
  }

/**
 * A condition to be used against `ContentGrouping` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ContentGroupingCondition = {
  /** Checks for equality with the object’s `broadcastSchedule` field. */
  broadcastSchedule?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `groupingType` field. */
  groupingType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `licenseUid` field. */
  licenseUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `startingDate` field. */
  startingDate?: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `subtitle` field. */
  subtitle?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `terminationDate` field. */
  terminationDate?: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `variant` field. */
  variant?: InputMaybe<ContentGroupingVariant>
}

/** A connection to a list of `ContentItem` values, with data from `_ContentGroupingToContentItem`. */
export type ContentGroupingContentItemsByContentGroupingToContentItemAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `_ContentGroupingToContentItem`, and the cursor to aid in pagination. */
    edges: Array<ContentGroupingContentItemsByContentGroupingToContentItemAAndBManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `_ContentGroupingToContentItem`. */
export type ContentGroupingContentItemsByContentGroupingToContentItemAAndBManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentGroupingToContentItem`. */
    _contentGroupingToContentItemsByB: _ContentGroupingToContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `ContentItem` at the end of the edge. */
    node: ContentItem
  }

/** A `ContentItem` edge in the connection, with data from `_ContentGroupingToContentItem`. */
export type ContentGroupingContentItemsByContentGroupingToContentItemAAndBManyToManyEdge_ContentGroupingToContentItemsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentGroupingToContentItemCondition>
    filter: InputMaybe<_ContentGroupingToContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentGroupingToContentItemsOrderBy>>
  }

/** A filter to be used against `ContentGrouping` object types. All fields are combined with a logical ‘and.’ */
export type ContentGroupingFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ContentGroupingFilter>>
  /** Filter by the object’s `broadcastSchedule` field. */
  broadcastSchedule?: InputMaybe<StringFilter>
  /** Filter by the object’s `contentItemsByPrimaryGrouping` relation. */
  contentItemsByPrimaryGrouping?: InputMaybe<ContentGroupingToManyContentItemFilter>
  /** Some related `contentItemsByPrimaryGrouping` exist. */
  contentItemsByPrimaryGroupingExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>
  /** Filter by the object’s `groupingType` field. */
  groupingType?: InputMaybe<StringFilter>
  /** Filter by the object’s `license` relation. */
  license?: InputMaybe<LicenseFilter>
  /** A related `license` exists. */
  licenseExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `licenseUid` field. */
  licenseUid?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<ContentGroupingFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ContentGroupingFilter>>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `startingDate` field. */
  startingDate?: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `subtitle` field. */
  subtitle?: InputMaybe<StringFilter>
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>
  /** Filter by the object’s `terminationDate` field. */
  terminationDate?: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
  /** Filter by the object’s `variant` field. */
  variant?: InputMaybe<ContentGroupingVariantFilter>
}

/** A connection to a list of `License` values, with data from `ContentItem`. */
export type ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `ContentItem`. */
export type ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItems: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `ContentItem`. */
export type ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidManyToManyEdgeContentItemsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A connection to a list of `PublicationService` values, with data from `ContentItem`. */
export type ContentGroupingPublicationServicesByContentItemPrimaryGroupingUidAndPublicationServiceUidManyToManyConnection =
  {
    /** A list of edges which contains the `PublicationService`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<ContentGroupingPublicationServicesByContentItemPrimaryGroupingUidAndPublicationServiceUidManyToManyEdge>
    /** A list of `PublicationService` objects. */
    nodes: Array<PublicationService>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `PublicationService` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `PublicationService` edge in the connection, with data from `ContentItem`. */
export type ContentGroupingPublicationServicesByContentItemPrimaryGroupingUidAndPublicationServiceUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItems: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `PublicationService` at the end of the edge. */
    node: PublicationService
  }

/** A `PublicationService` edge in the connection, with data from `ContentItem`. */
export type ContentGroupingPublicationServicesByContentItemPrimaryGroupingUidAndPublicationServiceUidManyToManyEdgeContentItemsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A filter to be used against many `ContentItem` object types. All fields are combined with a logical ‘and.’ */
export type ContentGroupingToManyContentItemFilter = {
  /** Every related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ContentItemFilter>
  /** No related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ContentItemFilter>
  /** Some related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ContentItemFilter>
}

export enum ContentGroupingVariant {
  Episodic = 'EPISODIC',
  Serial = 'SERIAL',
}

/** A filter to be used against ContentGroupingVariant fields. All fields are combined with a logical ‘and.’ */
export type ContentGroupingVariantFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ContentGroupingVariant>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ContentGroupingVariant>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ContentGroupingVariant>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ContentGroupingVariant>
  /** Included in the specified list. */
  in?: InputMaybe<Array<ContentGroupingVariant>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<ContentGroupingVariant>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ContentGroupingVariant>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ContentGroupingVariant>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ContentGroupingVariant>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ContentGroupingVariant>>
}

/** A connection to a list of `ContentGrouping` values. */
export type ContentGroupingsConnection = {
  /** A list of edges which contains the `ContentGrouping` and cursor to aid in pagination. */
  edges: Array<ContentGroupingsEdge>
  /** A list of `ContentGrouping` objects. */
  nodes: Array<ContentGrouping>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `ContentGrouping` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `ContentGrouping` edge in the connection. */
export type ContentGroupingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `ContentGrouping` at the end of the edge. */
  node: ContentGrouping
}

/** Methods to use when ordering `ContentGrouping`. */
export enum ContentGroupingsOrderBy {
  BroadcastScheduleAsc = 'BROADCAST_SCHEDULE_ASC',
  BroadcastScheduleDesc = 'BROADCAST_SCHEDULE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GroupingTypeAsc = 'GROUPING_TYPE_ASC',
  GroupingTypeDesc = 'GROUPING_TYPE_DESC',
  LicenseUidAsc = 'LICENSE_UID_ASC',
  LicenseUidDesc = 'LICENSE_UID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  StartingDateAsc = 'STARTING_DATE_ASC',
  StartingDateDesc = 'STARTING_DATE_DESC',
  SubtitleAsc = 'SUBTITLE_ASC',
  SubtitleDesc = 'SUBTITLE_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TerminationDateAsc = 'TERMINATION_DATE_ASC',
  TerminationDateDesc = 'TERMINATION_DATE_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
  VariantAsc = 'VARIANT_ASC',
  VariantDesc = 'VARIANT_DESC',
}

export type ContentItem = {
  /** Reads and enables pagination through a set of `BroadcastEvent`. */
  broadcastEvents: BroadcastEventsConnection
  /** Reads and enables pagination through a set of `Concept`. */
  concepts: ContentItemConceptsByConceptToContentItemBAndAManyToManyConnection
  content: Scalars['String']
  contentFormat: Scalars['String']
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupings: ContentItemContentGroupingsByContentGroupingToContentItemBAndAManyToManyConnection
  /** Reads and enables pagination through a set of `Contribution`. */
  contributions: ContentItemContributionsByContentItemToContributionAAndBManyToManyConnection
  /** Reads a single `License` that is related to this `ContentItem`. */
  license?: Maybe<License>
  licenseUid?: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: ContentItemMediaAssetsByContentItemToMediaAssetAAndBManyToManyConnection
  /** Reads a single `ContentGrouping` that is related to this `ContentItem`. */
  primaryGrouping?: Maybe<ContentGrouping>
  primaryGroupingUid?: Maybe<Scalars['String']>
  pubDate?: Maybe<Scalars['Datetime']>
  /** Reads a single `PublicationService` that is related to this `ContentItem`. */
  publicationService?: Maybe<PublicationService>
  publicationServiceUid?: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `PublicationService`. */
  publicationServicesByBroadcastEventContentItemUidAndBroadcastServiceUid: ContentItemPublicationServicesByBroadcastEventContentItemUidAndBroadcastServiceUidManyToManyConnection
  /** Reads a single `Revision` that is related to this `ContentItem`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  subtitle?: Maybe<Scalars['String']>
  summary?: Maybe<Scalars['String']>
  title: Scalars['String']
  uid: Scalars['String']
}

export type ContentItemBroadcastEventsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastEventCondition>
  filter: InputMaybe<BroadcastEventFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
}

export type ContentItemConceptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type ContentItemContentGroupingsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentGroupingCondition>
  filter: InputMaybe<ContentGroupingFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
}

export type ContentItemContributionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributionCondition>
  filter: InputMaybe<ContributionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributionsOrderBy>>
}

export type ContentItemMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

export type ContentItemPublicationServicesByBroadcastEventContentItemUidAndBroadcastServiceUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<PublicationServiceCondition>
    filter: InputMaybe<PublicationServiceFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<PublicationServicesOrderBy>>
  }

/** A connection to a list of `Concept` values, with data from `_ConceptToContentItem`. */
export type ContentItemConceptsByConceptToContentItemBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `Concept`, info from the `_ConceptToContentItem`, and the cursor to aid in pagination. */
    edges: Array<ContentItemConceptsByConceptToContentItemBAndAManyToManyEdge>
    /** A list of `Concept` objects. */
    nodes: Array<Concept>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Concept` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Concept` edge in the connection, with data from `_ConceptToContentItem`. */
export type ContentItemConceptsByConceptToContentItemBAndAManyToManyEdge = {
  /** Reads and enables pagination through a set of `_ConceptToContentItem`. */
  _conceptToContentItemsByA: _ConceptToContentItemsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Concept` at the end of the edge. */
  node: Concept
}

/** A `Concept` edge in the connection, with data from `_ConceptToContentItem`. */
export type ContentItemConceptsByConceptToContentItemBAndAManyToManyEdge_ConceptToContentItemsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ConceptToContentItemCondition>
    filter: InputMaybe<_ConceptToContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ConceptToContentItemsOrderBy>>
  }

/**
 * A condition to be used against `ContentItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ContentItemCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `contentFormat` field. */
  contentFormat?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `licenseUid` field. */
  licenseUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `primaryGroupingUid` field. */
  primaryGroupingUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `pubDate` field. */
  pubDate?: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `publicationServiceUid` field. */
  publicationServiceUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `subtitle` field. */
  subtitle?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentGrouping` values, with data from `_ContentGroupingToContentItem`. */
export type ContentItemContentGroupingsByContentGroupingToContentItemBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `ContentGrouping`, info from the `_ContentGroupingToContentItem`, and the cursor to aid in pagination. */
    edges: Array<ContentItemContentGroupingsByContentGroupingToContentItemBAndAManyToManyEdge>
    /** A list of `ContentGrouping` objects. */
    nodes: Array<ContentGrouping>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentGrouping` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentGrouping` edge in the connection, with data from `_ContentGroupingToContentItem`. */
export type ContentItemContentGroupingsByContentGroupingToContentItemBAndAManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentGroupingToContentItem`. */
    _contentGroupingToContentItemsByA: _ContentGroupingToContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `ContentGrouping` at the end of the edge. */
    node: ContentGrouping
  }

/** A `ContentGrouping` edge in the connection, with data from `_ContentGroupingToContentItem`. */
export type ContentItemContentGroupingsByContentGroupingToContentItemBAndAManyToManyEdge_ContentGroupingToContentItemsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentGroupingToContentItemCondition>
    filter: InputMaybe<_ContentGroupingToContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentGroupingToContentItemsOrderBy>>
  }

/** A connection to a list of `Contribution` values, with data from `_ContentItemToContribution`. */
export type ContentItemContributionsByContentItemToContributionAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `Contribution`, info from the `_ContentItemToContribution`, and the cursor to aid in pagination. */
    edges: Array<ContentItemContributionsByContentItemToContributionAAndBManyToManyEdge>
    /** A list of `Contribution` objects. */
    nodes: Array<Contribution>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Contribution` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Contribution` edge in the connection, with data from `_ContentItemToContribution`. */
export type ContentItemContributionsByContentItemToContributionAAndBManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentItemToContribution`. */
    _contentItemToContributionsByB: _ContentItemToContributionsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `Contribution` at the end of the edge. */
    node: Contribution
  }

/** A `Contribution` edge in the connection, with data from `_ContentItemToContribution`. */
export type ContentItemContributionsByContentItemToContributionAAndBManyToManyEdge_ContentItemToContributionsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentItemToContributionCondition>
    filter: InputMaybe<_ContentItemToContributionFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentItemToContributionsOrderBy>>
  }

/** A filter to be used against `ContentItem` object types. All fields are combined with a logical ‘and.’ */
export type ContentItemFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ContentItemFilter>>
  /** Filter by the object’s `broadcastEvents` relation. */
  broadcastEvents?: InputMaybe<ContentItemToManyBroadcastEventFilter>
  /** Some related `broadcastEvents` exist. */
  broadcastEventsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `content` field. */
  content?: InputMaybe<StringFilter>
  /** Filter by the object’s `contentFormat` field. */
  contentFormat?: InputMaybe<StringFilter>
  /** Filter by the object’s `license` relation. */
  license?: InputMaybe<LicenseFilter>
  /** A related `license` exists. */
  licenseExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `licenseUid` field. */
  licenseUid?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<ContentItemFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ContentItemFilter>>
  /** Filter by the object’s `primaryGrouping` relation. */
  primaryGrouping?: InputMaybe<ContentGroupingFilter>
  /** A related `primaryGrouping` exists. */
  primaryGroupingExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `primaryGroupingUid` field. */
  primaryGroupingUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `pubDate` field. */
  pubDate?: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `publicationService` relation. */
  publicationService?: InputMaybe<PublicationServiceFilter>
  /** A related `publicationService` exists. */
  publicationServiceExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `publicationServiceUid` field. */
  publicationServiceUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `subtitle` field. */
  subtitle?: InputMaybe<StringFilter>
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `MediaAsset` values, with data from `_ContentItemToMediaAsset`. */
export type ContentItemMediaAssetsByContentItemToMediaAssetAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `MediaAsset`, info from the `_ContentItemToMediaAsset`, and the cursor to aid in pagination. */
    edges: Array<ContentItemMediaAssetsByContentItemToMediaAssetAAndBManyToManyEdge>
    /** A list of `MediaAsset` objects. */
    nodes: Array<MediaAsset>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `MediaAsset` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `MediaAsset` edge in the connection, with data from `_ContentItemToMediaAsset`. */
export type ContentItemMediaAssetsByContentItemToMediaAssetAAndBManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentItemToMediaAsset`. */
    _contentItemToMediaAssetsByB: _ContentItemToMediaAssetsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `MediaAsset` at the end of the edge. */
    node: MediaAsset
  }

/** A `MediaAsset` edge in the connection, with data from `_ContentItemToMediaAsset`. */
export type ContentItemMediaAssetsByContentItemToMediaAssetAAndBManyToManyEdge_ContentItemToMediaAssetsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentItemToMediaAssetCondition>
    filter: InputMaybe<_ContentItemToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentItemToMediaAssetsOrderBy>>
  }

/** A connection to a list of `PublicationService` values, with data from `BroadcastEvent`. */
export type ContentItemPublicationServicesByBroadcastEventContentItemUidAndBroadcastServiceUidManyToManyConnection =
  {
    /** A list of edges which contains the `PublicationService`, info from the `BroadcastEvent`, and the cursor to aid in pagination. */
    edges: Array<ContentItemPublicationServicesByBroadcastEventContentItemUidAndBroadcastServiceUidManyToManyEdge>
    /** A list of `PublicationService` objects. */
    nodes: Array<PublicationService>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `PublicationService` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `PublicationService` edge in the connection, with data from `BroadcastEvent`. */
export type ContentItemPublicationServicesByBroadcastEventContentItemUidAndBroadcastServiceUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `BroadcastEvent`. */
    broadcastEventsByBroadcastService: BroadcastEventsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `PublicationService` at the end of the edge. */
    node: PublicationService
  }

/** A `PublicationService` edge in the connection, with data from `BroadcastEvent`. */
export type ContentItemPublicationServicesByBroadcastEventContentItemUidAndBroadcastServiceUidManyToManyEdgeBroadcastEventsByBroadcastServiceArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastEventCondition>
    filter: InputMaybe<BroadcastEventFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
  }

/** A filter to be used against many `BroadcastEvent` object types. All fields are combined with a logical ‘and.’ */
export type ContentItemToManyBroadcastEventFilter = {
  /** Every related `BroadcastEvent` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<BroadcastEventFilter>
  /** No related `BroadcastEvent` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<BroadcastEventFilter>
  /** Some related `BroadcastEvent` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<BroadcastEventFilter>
}

/** A connection to a list of `ContentItem` values. */
export type ContentItemsConnection = {
  /** A list of edges which contains the `ContentItem` and cursor to aid in pagination. */
  edges: Array<ContentItemsEdge>
  /** A list of `ContentItem` objects. */
  nodes: Array<ContentItem>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `ContentItem` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `ContentItem` edge in the connection. */
export type ContentItemsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `ContentItem` at the end of the edge. */
  node: ContentItem
}

/** Methods to use when ordering `ContentItem`. */
export enum ContentItemsOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  ContentFormatAsc = 'CONTENT_FORMAT_ASC',
  ContentFormatDesc = 'CONTENT_FORMAT_DESC',
  LicenseUidAsc = 'LICENSE_UID_ASC',
  LicenseUidDesc = 'LICENSE_UID_DESC',
  Natural = 'NATURAL',
  PrimaryGroupingUidAsc = 'PRIMARY_GROUPING_UID_ASC',
  PrimaryGroupingUidDesc = 'PRIMARY_GROUPING_UID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PublicationServiceUidAsc = 'PUBLICATION_SERVICE_UID_ASC',
  PublicationServiceUidDesc = 'PUBLICATION_SERVICE_UID_DESC',
  PubDateAsc = 'PUB_DATE_ASC',
  PubDateDesc = 'PUB_DATE_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  SubtitleAsc = 'SUBTITLE_ASC',
  SubtitleDesc = 'SUBTITLE_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Contribution = {
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ContributionContentItemsByContentItemToContributionBAndAManyToManyConnection
  /** Reads and enables pagination through a set of `Contributor`. */
  contributors: ContributionContributorsByContributionToContributorAAndBManyToManyConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: ContributionMediaAssetsByContributionToMediaAssetAAndBManyToManyConnection
  /** Reads a single `Revision` that is related to this `Contribution`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  role: Scalars['String']
  uid: Scalars['String']
}

export type ContributionContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type ContributionContributorsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributorCondition>
  filter: InputMaybe<ContributorFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributorsOrderBy>>
}

export type ContributionMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

/**
 * A condition to be used against `Contribution` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ContributionCondition = {
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `role` field. */
  role?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentItem` values, with data from `_ContentItemToContribution`. */
export type ContributionContentItemsByContentItemToContributionBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `_ContentItemToContribution`, and the cursor to aid in pagination. */
    edges: Array<ContributionContentItemsByContentItemToContributionBAndAManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `_ContentItemToContribution`. */
export type ContributionContentItemsByContentItemToContributionBAndAManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentItemToContribution`. */
    _contentItemToContributionsByA: _ContentItemToContributionsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `ContentItem` at the end of the edge. */
    node: ContentItem
  }

/** A `ContentItem` edge in the connection, with data from `_ContentItemToContribution`. */
export type ContributionContentItemsByContentItemToContributionBAndAManyToManyEdge_ContentItemToContributionsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentItemToContributionCondition>
    filter: InputMaybe<_ContentItemToContributionFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentItemToContributionsOrderBy>>
  }

/** A connection to a list of `Contributor` values, with data from `_ContributionToContributor`. */
export type ContributionContributorsByContributionToContributorAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `Contributor`, info from the `_ContributionToContributor`, and the cursor to aid in pagination. */
    edges: Array<ContributionContributorsByContributionToContributorAAndBManyToManyEdge>
    /** A list of `Contributor` objects. */
    nodes: Array<Contributor>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Contributor` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Contributor` edge in the connection, with data from `_ContributionToContributor`. */
export type ContributionContributorsByContributionToContributorAAndBManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContributionToContributor`. */
    _contributionToContributorsByB: _ContributionToContributorsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `Contributor` at the end of the edge. */
    node: Contributor
  }

/** A `Contributor` edge in the connection, with data from `_ContributionToContributor`. */
export type ContributionContributorsByContributionToContributorAAndBManyToManyEdge_ContributionToContributorsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContributionToContributorCondition>
    filter: InputMaybe<_ContributionToContributorFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContributionToContributorsOrderBy>>
  }

/** A filter to be used against `Contribution` object types. All fields are combined with a logical ‘and.’ */
export type ContributionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ContributionFilter>>
  /** Negates the expression. */
  not?: InputMaybe<ContributionFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ContributionFilter>>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `role` field. */
  role?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `MediaAsset` values, with data from `_ContributionToMediaAsset`. */
export type ContributionMediaAssetsByContributionToMediaAssetAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `MediaAsset`, info from the `_ContributionToMediaAsset`, and the cursor to aid in pagination. */
    edges: Array<ContributionMediaAssetsByContributionToMediaAssetAAndBManyToManyEdge>
    /** A list of `MediaAsset` objects. */
    nodes: Array<MediaAsset>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `MediaAsset` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `MediaAsset` edge in the connection, with data from `_ContributionToMediaAsset`. */
export type ContributionMediaAssetsByContributionToMediaAssetAAndBManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContributionToMediaAsset`. */
    _contributionToMediaAssetsByB: _ContributionToMediaAssetsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `MediaAsset` at the end of the edge. */
    node: MediaAsset
  }

/** A `MediaAsset` edge in the connection, with data from `_ContributionToMediaAsset`. */
export type ContributionMediaAssetsByContributionToMediaAssetAAndBManyToManyEdge_ContributionToMediaAssetsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContributionToMediaAssetCondition>
    filter: InputMaybe<_ContributionToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContributionToMediaAssetsOrderBy>>
  }

/** A connection to a list of `Contribution` values. */
export type ContributionsConnection = {
  /** A list of edges which contains the `Contribution` and cursor to aid in pagination. */
  edges: Array<ContributionsEdge>
  /** A list of `Contribution` objects. */
  nodes: Array<Contribution>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Contribution` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Contribution` edge in the connection. */
export type ContributionsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Contribution` at the end of the edge. */
  node: Contribution
}

/** Methods to use when ordering `Contribution`. */
export enum ContributionsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  RoleAsc = 'ROLE_ASC',
  RoleDesc = 'ROLE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Contributor = {
  contactInformation: Scalars['String']
  /** Reads and enables pagination through a set of `Contribution`. */
  contributions: ContributorContributionsByContributionToContributorBAndAManyToManyConnection
  name: Scalars['String']
  personOrOrganization: Scalars['String']
  /** Reads a single `File` that is related to this `Contributor`. */
  profilePicture?: Maybe<File>
  profilePictureUid: Scalars['String']
  /** Reads and enables pagination through a set of `PublicationService`. */
  publicationServicesByPublisher: PublicationServicesConnection
  /** Reads a single `Revision` that is related to this `Contributor`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  uid: Scalars['String']
}

export type ContributorContributionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributionCondition>
  filter: InputMaybe<ContributionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributionsOrderBy>>
}

export type ContributorPublicationServicesByPublisherArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<PublicationServiceCondition>
  filter: InputMaybe<PublicationServiceFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<PublicationServicesOrderBy>>
}

/**
 * A condition to be used against `Contributor` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ContributorCondition = {
  /** Checks for equality with the object’s `contactInformation` field. */
  contactInformation?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `personOrOrganization` field. */
  personOrOrganization?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `profilePictureUid` field. */
  profilePictureUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `Contribution` values, with data from `_ContributionToContributor`. */
export type ContributorContributionsByContributionToContributorBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `Contribution`, info from the `_ContributionToContributor`, and the cursor to aid in pagination. */
    edges: Array<ContributorContributionsByContributionToContributorBAndAManyToManyEdge>
    /** A list of `Contribution` objects. */
    nodes: Array<Contribution>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Contribution` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Contribution` edge in the connection, with data from `_ContributionToContributor`. */
export type ContributorContributionsByContributionToContributorBAndAManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContributionToContributor`. */
    _contributionToContributorsByA: _ContributionToContributorsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `Contribution` at the end of the edge. */
    node: Contribution
  }

/** A `Contribution` edge in the connection, with data from `_ContributionToContributor`. */
export type ContributorContributionsByContributionToContributorBAndAManyToManyEdge_ContributionToContributorsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContributionToContributorCondition>
    filter: InputMaybe<_ContributionToContributorFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContributionToContributorsOrderBy>>
  }

/** A filter to be used against `Contributor` object types. All fields are combined with a logical ‘and.’ */
export type ContributorFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ContributorFilter>>
  /** Filter by the object’s `contactInformation` field. */
  contactInformation?: InputMaybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<ContributorFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ContributorFilter>>
  /** Filter by the object’s `personOrOrganization` field. */
  personOrOrganization?: InputMaybe<StringFilter>
  /** Filter by the object’s `profilePicture` relation. */
  profilePicture?: InputMaybe<FileFilter>
  /** Filter by the object’s `profilePictureUid` field. */
  profilePictureUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `publicationServicesByPublisher` relation. */
  publicationServicesByPublisher?: InputMaybe<ContributorToManyPublicationServiceFilter>
  /** Some related `publicationServicesByPublisher` exist. */
  publicationServicesByPublisherExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A filter to be used against many `PublicationService` object types. All fields are combined with a logical ‘and.’ */
export type ContributorToManyPublicationServiceFilter = {
  /** Every related `PublicationService` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PublicationServiceFilter>
  /** No related `PublicationService` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PublicationServiceFilter>
  /** Some related `PublicationService` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PublicationServiceFilter>
}

/** A connection to a list of `Contributor` values. */
export type ContributorsConnection = {
  /** A list of edges which contains the `Contributor` and cursor to aid in pagination. */
  edges: Array<ContributorsEdge>
  /** A list of `Contributor` objects. */
  nodes: Array<Contributor>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Contributor` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Contributor` edge in the connection. */
export type ContributorsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Contributor` at the end of the edge. */
  node: Contributor
}

/** Methods to use when ordering `Contributor`. */
export enum ContributorsOrderBy {
  ContactInformationAsc = 'CONTACT_INFORMATION_ASC',
  ContactInformationDesc = 'CONTACT_INFORMATION_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PersonOrOrganizationAsc = 'PERSON_OR_ORGANIZATION_ASC',
  PersonOrOrganizationDesc = 'PERSON_OR_ORGANIZATION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProfilePictureUidAsc = 'PROFILE_PICTURE_UID_ASC',
  ProfilePictureUidDesc = 'PROFILE_PICTURE_UID_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type DataSource = {
  active?: Maybe<Scalars['Boolean']>
  config?: Maybe<Scalars['JSON']>
  cursor?: Maybe<Scalars['String']>
  pluginUid: Scalars['String']
  /** Reads and enables pagination through a set of `SourceRecord`. */
  sourceRecords: SourceRecordsConnection
  uid: Scalars['String']
}

export type DataSourceSourceRecordsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<SourceRecordCondition>
  filter: InputMaybe<SourceRecordFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<SourceRecordsOrderBy>>
}

/**
 * A condition to be used against `DataSource` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DataSourceCondition = {
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `config` field. */
  config?: InputMaybe<Scalars['JSON']>
  /** Checks for equality with the object’s `cursor` field. */
  cursor?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `pluginUid` field. */
  pluginUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `DataSource` object types. All fields are combined with a logical ‘and.’ */
export type DataSourceFilter = {
  /** Filter by the object’s `active` field. */
  active?: InputMaybe<BooleanFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataSourceFilter>>
  /** Filter by the object’s `config` field. */
  config?: InputMaybe<JsonFilter>
  /** Filter by the object’s `cursor` field. */
  cursor?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<DataSourceFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataSourceFilter>>
  /** Filter by the object’s `pluginUid` field. */
  pluginUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `sourceRecords` relation. */
  sourceRecords?: InputMaybe<DataSourceToManySourceRecordFilter>
  /** Some related `sourceRecords` exist. */
  sourceRecordsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A filter to be used against many `SourceRecord` object types. All fields are combined with a logical ‘and.’ */
export type DataSourceToManySourceRecordFilter = {
  /** Every related `SourceRecord` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SourceRecordFilter>
  /** No related `SourceRecord` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SourceRecordFilter>
  /** Some related `SourceRecord` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SourceRecordFilter>
}

/** A connection to a list of `DataSource` values. */
export type DataSourcesConnection = {
  /** A list of edges which contains the `DataSource` and cursor to aid in pagination. */
  edges: Array<DataSourcesEdge>
  /** A list of `DataSource` objects. */
  nodes: Array<DataSource>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `DataSource` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `DataSource` edge in the connection. */
export type DataSourcesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `DataSource` at the end of the edge. */
  node: DataSource
}

/** Methods to use when ordering `DataSource`. */
export enum DataSourcesOrderBy {
  ActiveAsc = 'ACTIVE_ASC',
  ActiveDesc = 'ACTIVE_DESC',
  ConfigAsc = 'CONFIG_ASC',
  ConfigDesc = 'CONFIG_DESC',
  CursorAsc = 'CURSOR_ASC',
  CursorDesc = 'CURSOR_DESC',
  Natural = 'NATURAL',
  PluginUidAsc = 'PLUGIN_UID_ASC',
  PluginUidDesc = 'PLUGIN_UID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']>>
}

/** A connection to a list of `Entity` values. */
export type EntitiesConnection = {
  /** A list of edges which contains the `Entity` and cursor to aid in pagination. */
  edges: Array<EntitiesEdge>
  /** A list of `Entity` objects. */
  nodes: Array<Entity>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Entity` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Entity` edge in the connection. */
export type EntitiesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Entity` at the end of the edge. */
  node: Entity
}

/** Methods to use when ordering `Entity`. */
export enum EntitiesOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Entity = {
  /** Reads and enables pagination through a set of `Metadatum`. */
  metadataByTarget: MetadataConnection
  /** Reads a single `Revision` that is related to this `Entity`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  type: Scalars['String']
  uid: Scalars['String']
}

export type EntityMetadataByTargetArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MetadatumCondition>
  filter: InputMaybe<MetadatumFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MetadataOrderBy>>
}

/** A condition to be used against `Entity` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EntityCondition = {
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Entity` object types. All fields are combined with a logical ‘and.’ */
export type EntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EntityFilter>>
  /** Filter by the object’s `metadataByTarget` relation. */
  metadataByTarget?: InputMaybe<EntityToManyMetadatumFilter>
  /** Some related `metadataByTarget` exist. */
  metadataByTargetExist?: InputMaybe<Scalars['Boolean']>
  /** Negates the expression. */
  not?: InputMaybe<EntityFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EntityFilter>>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A filter to be used against many `Metadatum` object types. All fields are combined with a logical ‘and.’ */
export type EntityToManyMetadatumFilter = {
  /** Every related `Metadatum` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MetadatumFilter>
  /** No related `Metadatum` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MetadatumFilter>
  /** Some related `Metadatum` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MetadatumFilter>
}

export type FailedDatasourceFetch = {
  datasourceUid: Scalars['String']
  errorDetails?: Maybe<Scalars['JSON']>
  errorMessage: Scalars['String']
  timestamp: Scalars['Datetime']
  uri: Scalars['String']
}

/**
 * A condition to be used against `FailedDatasourceFetch` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type FailedDatasourceFetchCondition = {
  /** Checks for equality with the object’s `datasourceUid` field. */
  datasourceUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `errorDetails` field. */
  errorDetails?: InputMaybe<Scalars['JSON']>
  /** Checks for equality with the object’s `errorMessage` field. */
  errorMessage?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `uri` field. */
  uri?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `FailedDatasourceFetch` object types. All fields are combined with a logical ‘and.’ */
export type FailedDatasourceFetchFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FailedDatasourceFetchFilter>>
  /** Filter by the object’s `datasourceUid` field. */
  datasourceUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `errorDetails` field. */
  errorDetails?: InputMaybe<JsonFilter>
  /** Filter by the object’s `errorMessage` field. */
  errorMessage?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<FailedDatasourceFetchFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FailedDatasourceFetchFilter>>
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `uri` field. */
  uri?: InputMaybe<StringFilter>
}

/** A connection to a list of `FailedDatasourceFetch` values. */
export type FailedDatasourceFetchesConnection = {
  /** A list of edges which contains the `FailedDatasourceFetch` and cursor to aid in pagination. */
  edges: Array<FailedDatasourceFetchesEdge>
  /** A list of `FailedDatasourceFetch` objects. */
  nodes: Array<FailedDatasourceFetch>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `FailedDatasourceFetch` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `FailedDatasourceFetch` edge in the connection. */
export type FailedDatasourceFetchesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `FailedDatasourceFetch` at the end of the edge. */
  node: FailedDatasourceFetch
}

/** Methods to use when ordering `FailedDatasourceFetch`. */
export enum FailedDatasourceFetchesOrderBy {
  DatasourceUidAsc = 'DATASOURCE_UID_ASC',
  DatasourceUidDesc = 'DATASOURCE_UID_DESC',
  ErrorDetailsAsc = 'ERROR_DETAILS_ASC',
  ErrorDetailsDesc = 'ERROR_DETAILS_DESC',
  ErrorMessageAsc = 'ERROR_MESSAGE_ASC',
  ErrorMessageDesc = 'ERROR_MESSAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  UriAsc = 'URI_ASC',
  UriDesc = 'URI_DESC',
}

export type File = {
  additionalMetadata?: Maybe<Scalars['String']>
  bitrate?: Maybe<Scalars['Int']>
  cid?: Maybe<Scalars['String']>
  codec?: Maybe<Scalars['String']>
  contentSize?: Maybe<Scalars['Int']>
  contentUrl: Scalars['String']
  /** Reads and enables pagination through a set of `Contributor`. */
  contributorsByProfilePicture: ContributorsConnection
  duration?: Maybe<Scalars['Float']>
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetFileUidAndTeaserImageUid: FileFilesByMediaAssetFileUidAndTeaserImageUidManyToManyConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetTeaserImageUidAndFileUid: FileFilesByMediaAssetTeaserImageUidAndFileUidManyToManyConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByMediaAssetFileUidAndLicenseUid: FileLicensesByMediaAssetFileUidAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByMediaAssetTeaserImageUidAndLicenseUid: FileLicensesByMediaAssetTeaserImageUidAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssetsByTeaserImage: MediaAssetsConnection
  mimeType?: Maybe<Scalars['String']>
  resolution?: Maybe<Scalars['String']>
  /** Reads a single `Revision` that is related to this `File`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  uid: Scalars['String']
}

export type FileContributorsByProfilePictureArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributorCondition>
  filter: InputMaybe<ContributorFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributorsOrderBy>>
}

export type FileFilesByMediaAssetFileUidAndTeaserImageUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type FileFilesByMediaAssetTeaserImageUidAndFileUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type FileLicensesByMediaAssetFileUidAndLicenseUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type FileLicensesByMediaAssetTeaserImageUidAndLicenseUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type FileMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

export type FileMediaAssetsByTeaserImageArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

/** A condition to be used against `File` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FileCondition = {
  /** Checks for equality with the object’s `additionalMetadata` field. */
  additionalMetadata?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `bitrate` field. */
  bitrate?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `cid` field. */
  cid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `codec` field. */
  codec?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `contentSize` field. */
  contentSize?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `contentUrl` field. */
  contentUrl?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `duration` field. */
  duration?: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `mimeType` field. */
  mimeType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `resolution` field. */
  resolution?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type FileFilesByMediaAssetFileUidAndTeaserImageUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<FileFilesByMediaAssetFileUidAndTeaserImageUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type FileFilesByMediaAssetFileUidAndTeaserImageUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssetsByTeaserImage: MediaAssetsConnection
  /** The `File` at the end of the edge. */
  node: File
}

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type FileFilesByMediaAssetFileUidAndTeaserImageUidManyToManyEdgeMediaAssetsByTeaserImageArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type FileFilesByMediaAssetTeaserImageUidAndFileUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<FileFilesByMediaAssetTeaserImageUidAndFileUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type FileFilesByMediaAssetTeaserImageUidAndFileUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** The `File` at the end of the edge. */
  node: File
}

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type FileFilesByMediaAssetTeaserImageUidAndFileUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A filter to be used against `File` object types. All fields are combined with a logical ‘and.’ */
export type FileFilter = {
  /** Filter by the object’s `additionalMetadata` field. */
  additionalMetadata?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FileFilter>>
  /** Filter by the object’s `bitrate` field. */
  bitrate?: InputMaybe<IntFilter>
  /** Filter by the object’s `cid` field. */
  cid?: InputMaybe<StringFilter>
  /** Filter by the object’s `codec` field. */
  codec?: InputMaybe<StringFilter>
  /** Filter by the object’s `contentSize` field. */
  contentSize?: InputMaybe<IntFilter>
  /** Filter by the object’s `contentUrl` field. */
  contentUrl?: InputMaybe<StringFilter>
  /** Filter by the object’s `contributorsByProfilePicture` relation. */
  contributorsByProfilePicture?: InputMaybe<FileToManyContributorFilter>
  /** Some related `contributorsByProfilePicture` exist. */
  contributorsByProfilePictureExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `duration` field. */
  duration?: InputMaybe<FloatFilter>
  /** Filter by the object’s `mediaAssets` relation. */
  mediaAssets?: InputMaybe<FileToManyMediaAssetFilter>
  /** Filter by the object’s `mediaAssetsByTeaserImage` relation. */
  mediaAssetsByTeaserImage?: InputMaybe<FileToManyMediaAssetFilter>
  /** Some related `mediaAssetsByTeaserImage` exist. */
  mediaAssetsByTeaserImageExist?: InputMaybe<Scalars['Boolean']>
  /** Some related `mediaAssets` exist. */
  mediaAssetsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `mimeType` field. */
  mimeType?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<FileFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FileFilter>>
  /** Filter by the object’s `resolution` field. */
  resolution?: InputMaybe<StringFilter>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `License` values, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetFileUidAndLicenseUidManyToManyConnection = {
  /** A list of edges which contains the `License`, info from the `MediaAsset`, and the cursor to aid in pagination. */
  edges: Array<FileLicensesByMediaAssetFileUidAndLicenseUidManyToManyEdge>
  /** A list of `License` objects. */
  nodes: Array<License>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `License` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetFileUidAndLicenseUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** The `License` at the end of the edge. */
  node: License
}

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetFileUidAndLicenseUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `License` values, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetTeaserImageUidAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<FileLicensesByMediaAssetTeaserImageUidAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetTeaserImageUidAndLicenseUidManyToManyEdge =
  {
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** Reads and enables pagination through a set of `MediaAsset`. */
    mediaAssets: MediaAssetsConnection
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetTeaserImageUidAndLicenseUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A filter to be used against many `Contributor` object types. All fields are combined with a logical ‘and.’ */
export type FileToManyContributorFilter = {
  /** Every related `Contributor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ContributorFilter>
  /** No related `Contributor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ContributorFilter>
  /** Some related `Contributor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ContributorFilter>
}

/** A filter to be used against many `MediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type FileToManyMediaAssetFilter = {
  /** Every related `MediaAsset` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MediaAssetFilter>
  /** No related `MediaAsset` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MediaAssetFilter>
  /** Some related `MediaAsset` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MediaAssetFilter>
}

/** A connection to a list of `File` values. */
export type FilesConnection = {
  /** A list of edges which contains the `File` and cursor to aid in pagination. */
  edges: Array<FilesEdge>
  /** A list of `File` objects. */
  nodes: Array<File>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `File` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `File` edge in the connection. */
export type FilesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `File` at the end of the edge. */
  node: File
}

/** Methods to use when ordering `File`. */
export enum FilesOrderBy {
  AdditionalMetadataAsc = 'ADDITIONAL_METADATA_ASC',
  AdditionalMetadataDesc = 'ADDITIONAL_METADATA_DESC',
  BitrateAsc = 'BITRATE_ASC',
  BitrateDesc = 'BITRATE_DESC',
  CidAsc = 'CID_ASC',
  CidDesc = 'CID_DESC',
  CodecAsc = 'CODEC_ASC',
  CodecDesc = 'CODEC_DESC',
  ContentSizeAsc = 'CONTENT_SIZE_ASC',
  ContentSizeDesc = 'CONTENT_SIZE_DESC',
  ContentUrlAsc = 'CONTENT_URL_ASC',
  ContentUrlDesc = 'CONTENT_URL_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  MimeTypeAsc = 'MIME_TYPE_ASC',
  MimeTypeDesc = 'MIME_TYPE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ResolutionAsc = 'RESOLUTION_ASC',
  ResolutionDesc = 'RESOLUTION_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Float']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Float']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Float']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Float']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Float']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Float']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Float']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Float']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Float']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Float']>>
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']>>
}

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']>
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']>
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']>>
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']>>
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']>>
}

export type Keypair = {
  did: Scalars['String']
  name?: Maybe<Scalars['String']>
  scope: KeypairScope
  secret: Scalars['String']
}

/** A condition to be used against `Keypair` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type KeypairCondition = {
  /** Checks for equality with the object’s `did` field. */
  did?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `scope` field. */
  scope?: InputMaybe<KeypairScope>
  /** Checks for equality with the object’s `secret` field. */
  secret?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Keypair` object types. All fields are combined with a logical ‘and.’ */
export type KeypairFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<KeypairFilter>>
  /** Filter by the object’s `did` field. */
  did?: InputMaybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<KeypairFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<KeypairFilter>>
  /** Filter by the object’s `scope` field. */
  scope?: InputMaybe<KeypairScopeFilter>
  /** Filter by the object’s `secret` field. */
  secret?: InputMaybe<StringFilter>
}

export enum KeypairScope {
  Instance = 'INSTANCE',
  Repo = 'REPO',
}

/** A filter to be used against KeypairScope fields. All fields are combined with a logical ‘and.’ */
export type KeypairScopeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<KeypairScope>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<KeypairScope>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<KeypairScope>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<KeypairScope>
  /** Included in the specified list. */
  in?: InputMaybe<Array<KeypairScope>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<KeypairScope>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<KeypairScope>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<KeypairScope>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<KeypairScope>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<KeypairScope>>
}

/** A connection to a list of `Keypair` values. */
export type KeypairsConnection = {
  /** A list of edges which contains the `Keypair` and cursor to aid in pagination. */
  edges: Array<KeypairsEdge>
  /** A list of `Keypair` objects. */
  nodes: Array<Keypair>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Keypair` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Keypair` edge in the connection. */
export type KeypairsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Keypair` at the end of the edge. */
  node: Keypair
}

/** Methods to use when ordering `Keypair`. */
export enum KeypairsOrderBy {
  DidAsc = 'DID_ASC',
  DidDesc = 'DID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScopeAsc = 'SCOPE_ASC',
  ScopeDesc = 'SCOPE_DESC',
  SecretAsc = 'SECRET_ASC',
  SecretDesc = 'SECRET_DESC',
}

export type License = {
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupings: ContentGroupingsConnection
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupingsByContentItemLicenseUidAndPrimaryGroupingUid: LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidManyToManyConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ContentItemsConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetLicenseUidAndFileUid: LicenseFilesByMediaAssetLicenseUidAndFileUidManyToManyConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetLicenseUidAndTeaserImageUid: LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidManyToManyConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  name: Scalars['String']
  /** Reads and enables pagination through a set of `PublicationService`. */
  publicationServicesByContentItemLicenseUidAndPublicationServiceUid: LicensePublicationServicesByContentItemLicenseUidAndPublicationServiceUidManyToManyConnection
  /** Reads a single `Revision` that is related to this `License`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  uid: Scalars['String']
}

export type LicenseContentGroupingsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentGroupingCondition>
  filter: InputMaybe<ContentGroupingFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
}

export type LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentGroupingCondition>
    filter: InputMaybe<ContentGroupingFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
  }

export type LicenseContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type LicenseFilesByMediaAssetLicenseUidAndFileUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type LicenseMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

export type LicensePublicationServicesByContentItemLicenseUidAndPublicationServiceUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<PublicationServiceCondition>
    filter: InputMaybe<PublicationServiceFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<PublicationServicesOrderBy>>
  }

/** A condition to be used against `License` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LicenseCondition = {
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentGrouping` values, with data from `ContentItem`. */
export type LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidManyToManyConnection =
  {
    /** A list of edges which contains the `ContentGrouping`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidManyToManyEdge>
    /** A list of `ContentGrouping` objects. */
    nodes: Array<ContentGrouping>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentGrouping` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentGrouping` edge in the connection, with data from `ContentItem`. */
export type LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItemsByPrimaryGrouping: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `ContentGrouping` at the end of the edge. */
    node: ContentGrouping
  }

/** A `ContentGrouping` edge in the connection, with data from `ContentItem`. */
export type LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidManyToManyEdgeContentItemsByPrimaryGroupingArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndFileUidManyToManyConnection = {
  /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
  edges: Array<LicenseFilesByMediaAssetLicenseUidAndFileUidManyToManyEdge>
  /** A list of `File` objects. */
  nodes: Array<File>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `File` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndFileUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** The `File` at the end of the edge. */
  node: File
}

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndFileUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidManyToManyEdge =
  {
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** Reads and enables pagination through a set of `MediaAsset`. */
    mediaAssetsByTeaserImage: MediaAssetsConnection
    /** The `File` at the end of the edge. */
    node: File
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidManyToManyEdgeMediaAssetsByTeaserImageArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A filter to be used against `License` object types. All fields are combined with a logical ‘and.’ */
export type LicenseFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LicenseFilter>>
  /** Filter by the object’s `contentGroupings` relation. */
  contentGroupings?: InputMaybe<LicenseToManyContentGroupingFilter>
  /** Some related `contentGroupings` exist. */
  contentGroupingsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `contentItems` relation. */
  contentItems?: InputMaybe<LicenseToManyContentItemFilter>
  /** Some related `contentItems` exist. */
  contentItemsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `mediaAssets` relation. */
  mediaAssets?: InputMaybe<LicenseToManyMediaAssetFilter>
  /** Some related `mediaAssets` exist. */
  mediaAssetsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<LicenseFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LicenseFilter>>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `PublicationService` values, with data from `ContentItem`. */
export type LicensePublicationServicesByContentItemLicenseUidAndPublicationServiceUidManyToManyConnection =
  {
    /** A list of edges which contains the `PublicationService`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<LicensePublicationServicesByContentItemLicenseUidAndPublicationServiceUidManyToManyEdge>
    /** A list of `PublicationService` objects. */
    nodes: Array<PublicationService>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `PublicationService` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `PublicationService` edge in the connection, with data from `ContentItem`. */
export type LicensePublicationServicesByContentItemLicenseUidAndPublicationServiceUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItems: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `PublicationService` at the end of the edge. */
    node: PublicationService
  }

/** A `PublicationService` edge in the connection, with data from `ContentItem`. */
export type LicensePublicationServicesByContentItemLicenseUidAndPublicationServiceUidManyToManyEdgeContentItemsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A filter to be used against many `ContentGrouping` object types. All fields are combined with a logical ‘and.’ */
export type LicenseToManyContentGroupingFilter = {
  /** Every related `ContentGrouping` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ContentGroupingFilter>
  /** No related `ContentGrouping` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ContentGroupingFilter>
  /** Some related `ContentGrouping` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ContentGroupingFilter>
}

/** A filter to be used against many `ContentItem` object types. All fields are combined with a logical ‘and.’ */
export type LicenseToManyContentItemFilter = {
  /** Every related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ContentItemFilter>
  /** No related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ContentItemFilter>
  /** Some related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ContentItemFilter>
}

/** A filter to be used against many `MediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type LicenseToManyMediaAssetFilter = {
  /** Every related `MediaAsset` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MediaAssetFilter>
  /** No related `MediaAsset` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MediaAssetFilter>
  /** Some related `MediaAsset` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MediaAssetFilter>
}

/** A connection to a list of `License` values. */
export type LicensesConnection = {
  /** A list of edges which contains the `License` and cursor to aid in pagination. */
  edges: Array<LicensesEdge>
  /** A list of `License` objects. */
  nodes: Array<License>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `License` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `License` edge in the connection. */
export type LicensesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `License` at the end of the edge. */
  node: License
}

/** Methods to use when ordering `License`. */
export enum LicensesOrderBy {
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type MediaAsset = {
  /** Reads and enables pagination through a set of `Chapter`. */
  chapters: ChaptersConnection
  /** Reads and enables pagination through a set of `Concept`. */
  concepts: MediaAssetConceptsByConceptToMediaAssetBAndAManyToManyConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: MediaAssetContentItemsByContentItemToMediaAssetBAndAManyToManyConnection
  /** Reads and enables pagination through a set of `Contribution`. */
  contributions: MediaAssetContributionsByContributionToMediaAssetBAndAManyToManyConnection
  description?: Maybe<Scalars['String']>
  duration?: Maybe<Scalars['Float']>
  /** Reads a single `File` that is related to this `MediaAsset`. */
  file?: Maybe<File>
  fileUid: Scalars['String']
  /** Reads a single `License` that is related to this `MediaAsset`. */
  license?: Maybe<License>
  licenseUid?: Maybe<Scalars['String']>
  mediaType: Scalars['String']
  /** Reads a single `Revision` that is related to this `MediaAsset`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  /** Reads a single `File` that is related to this `MediaAsset`. */
  teaserImage?: Maybe<File>
  teaserImageUid?: Maybe<Scalars['String']>
  title: Scalars['String']
  /** Reads and enables pagination through a set of `Transcript`. */
  transcripts: TranscriptsConnection
  /** Reads and enables pagination through a set of `Translation`. */
  translations: TranslationsConnection
  uid: Scalars['String']
}

export type MediaAssetChaptersArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ChapterCondition>
  filter: InputMaybe<ChapterFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ChaptersOrderBy>>
}

export type MediaAssetConceptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type MediaAssetContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type MediaAssetContributionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributionCondition>
  filter: InputMaybe<ContributionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributionsOrderBy>>
}

export type MediaAssetTranscriptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<TranscriptCondition>
  filter: InputMaybe<TranscriptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<TranscriptsOrderBy>>
}

export type MediaAssetTranslationsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<TranslationCondition>
  filter: InputMaybe<TranslationFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<TranslationsOrderBy>>
}

/** A connection to a list of `Concept` values, with data from `_ConceptToMediaAsset`. */
export type MediaAssetConceptsByConceptToMediaAssetBAndAManyToManyConnection = {
  /** A list of edges which contains the `Concept`, info from the `_ConceptToMediaAsset`, and the cursor to aid in pagination. */
  edges: Array<MediaAssetConceptsByConceptToMediaAssetBAndAManyToManyEdge>
  /** A list of `Concept` objects. */
  nodes: Array<Concept>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Concept` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Concept` edge in the connection, with data from `_ConceptToMediaAsset`. */
export type MediaAssetConceptsByConceptToMediaAssetBAndAManyToManyEdge = {
  /** Reads and enables pagination through a set of `_ConceptToMediaAsset`. */
  _conceptToMediaAssetsByA: _ConceptToMediaAssetsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Concept` at the end of the edge. */
  node: Concept
}

/** A `Concept` edge in the connection, with data from `_ConceptToMediaAsset`. */
export type MediaAssetConceptsByConceptToMediaAssetBAndAManyToManyEdge_ConceptToMediaAssetsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ConceptToMediaAssetCondition>
    filter: InputMaybe<_ConceptToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ConceptToMediaAssetsOrderBy>>
  }

/**
 * A condition to be used against `MediaAsset` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MediaAssetCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `duration` field. */
  duration?: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `fileUid` field. */
  fileUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `licenseUid` field. */
  licenseUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `mediaType` field. */
  mediaType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `teaserImageUid` field. */
  teaserImageUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentItem` values, with data from `_ContentItemToMediaAsset`. */
export type MediaAssetContentItemsByContentItemToMediaAssetBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `_ContentItemToMediaAsset`, and the cursor to aid in pagination. */
    edges: Array<MediaAssetContentItemsByContentItemToMediaAssetBAndAManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `_ContentItemToMediaAsset`. */
export type MediaAssetContentItemsByContentItemToMediaAssetBAndAManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentItemToMediaAsset`. */
    _contentItemToMediaAssetsByA: _ContentItemToMediaAssetsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `ContentItem` at the end of the edge. */
    node: ContentItem
  }

/** A `ContentItem` edge in the connection, with data from `_ContentItemToMediaAsset`. */
export type MediaAssetContentItemsByContentItemToMediaAssetBAndAManyToManyEdge_ContentItemToMediaAssetsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentItemToMediaAssetCondition>
    filter: InputMaybe<_ContentItemToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentItemToMediaAssetsOrderBy>>
  }

/** A connection to a list of `Contribution` values, with data from `_ContributionToMediaAsset`. */
export type MediaAssetContributionsByContributionToMediaAssetBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `Contribution`, info from the `_ContributionToMediaAsset`, and the cursor to aid in pagination. */
    edges: Array<MediaAssetContributionsByContributionToMediaAssetBAndAManyToManyEdge>
    /** A list of `Contribution` objects. */
    nodes: Array<Contribution>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Contribution` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Contribution` edge in the connection, with data from `_ContributionToMediaAsset`. */
export type MediaAssetContributionsByContributionToMediaAssetBAndAManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContributionToMediaAsset`. */
    _contributionToMediaAssetsByA: _ContributionToMediaAssetsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `Contribution` at the end of the edge. */
    node: Contribution
  }

/** A `Contribution` edge in the connection, with data from `_ContributionToMediaAsset`. */
export type MediaAssetContributionsByContributionToMediaAssetBAndAManyToManyEdge_ContributionToMediaAssetsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContributionToMediaAssetCondition>
    filter: InputMaybe<_ContributionToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContributionToMediaAssetsOrderBy>>
  }

/** A filter to be used against `MediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type MediaAssetFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MediaAssetFilter>>
  /** Filter by the object’s `chapters` relation. */
  chapters?: InputMaybe<MediaAssetToManyChapterFilter>
  /** Some related `chapters` exist. */
  chaptersExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>
  /** Filter by the object’s `duration` field. */
  duration?: InputMaybe<FloatFilter>
  /** Filter by the object’s `file` relation. */
  file?: InputMaybe<FileFilter>
  /** Filter by the object’s `fileUid` field. */
  fileUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `license` relation. */
  license?: InputMaybe<LicenseFilter>
  /** A related `license` exists. */
  licenseExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `licenseUid` field. */
  licenseUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `mediaType` field. */
  mediaType?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<MediaAssetFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MediaAssetFilter>>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `teaserImage` relation. */
  teaserImage?: InputMaybe<FileFilter>
  /** A related `teaserImage` exists. */
  teaserImageExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `teaserImageUid` field. */
  teaserImageUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>
  /** Filter by the object’s `transcripts` relation. */
  transcripts?: InputMaybe<MediaAssetToManyTranscriptFilter>
  /** Some related `transcripts` exist. */
  transcriptsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<MediaAssetToManyTranslationFilter>
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A filter to be used against many `Chapter` object types. All fields are combined with a logical ‘and.’ */
export type MediaAssetToManyChapterFilter = {
  /** Every related `Chapter` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ChapterFilter>
  /** No related `Chapter` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ChapterFilter>
  /** Some related `Chapter` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ChapterFilter>
}

/** A filter to be used against many `Transcript` object types. All fields are combined with a logical ‘and.’ */
export type MediaAssetToManyTranscriptFilter = {
  /** Every related `Transcript` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TranscriptFilter>
  /** No related `Transcript` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TranscriptFilter>
  /** Some related `Transcript` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TranscriptFilter>
}

/** A filter to be used against many `Translation` object types. All fields are combined with a logical ‘and.’ */
export type MediaAssetToManyTranslationFilter = {
  /** Every related `Translation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TranslationFilter>
  /** No related `Translation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TranslationFilter>
  /** Some related `Translation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TranslationFilter>
}

/** A connection to a list of `MediaAsset` values. */
export type MediaAssetsConnection = {
  /** A list of edges which contains the `MediaAsset` and cursor to aid in pagination. */
  edges: Array<MediaAssetsEdge>
  /** A list of `MediaAsset` objects. */
  nodes: Array<MediaAsset>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `MediaAsset` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `MediaAsset` edge in the connection. */
export type MediaAssetsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `MediaAsset` at the end of the edge. */
  node: MediaAsset
}

/** Methods to use when ordering `MediaAsset`. */
export enum MediaAssetsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  FileUidAsc = 'FILE_UID_ASC',
  FileUidDesc = 'FILE_UID_DESC',
  LicenseUidAsc = 'LICENSE_UID_ASC',
  LicenseUidDesc = 'LICENSE_UID_DESC',
  MediaTypeAsc = 'MEDIA_TYPE_ASC',
  MediaTypeDesc = 'MEDIA_TYPE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  TeaserImageUidAsc = 'TEASER_IMAGE_UID_ASC',
  TeaserImageUidDesc = 'TEASER_IMAGE_UID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

/** A connection to a list of `Metadatum` values. */
export type MetadataConnection = {
  /** A list of edges which contains the `Metadatum` and cursor to aid in pagination. */
  edges: Array<MetadataEdge>
  /** A list of `Metadatum` objects. */
  nodes: Array<Metadatum>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Metadatum` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Metadatum` edge in the connection. */
export type MetadataEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Metadatum` at the end of the edge. */
  node: Metadatum
}

/** Methods to use when ordering `Metadatum`. */
export enum MetadataOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  NamespaceAsc = 'NAMESPACE_ASC',
  NamespaceDesc = 'NAMESPACE_DESC',
  Natural = 'NATURAL',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  TargetUidAsc = 'TARGET_UID_ASC',
  TargetUidDesc = 'TARGET_UID_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Metadatum = {
  content: Scalars['JSON']
  namespace: Scalars['String']
  /** Reads a single `Revision` that is related to this `Metadatum`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  /** Reads a single `Entity` that is related to this `Metadatum`. */
  target?: Maybe<Entity>
  targetUid: Scalars['String']
  uid: Scalars['String']
}

/**
 * A condition to be used against `Metadatum` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MetadatumCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['JSON']>
  /** Checks for equality with the object’s `namespace` field. */
  namespace?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `targetUid` field. */
  targetUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Metadatum` object types. All fields are combined with a logical ‘and.’ */
export type MetadatumFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MetadatumFilter>>
  /** Filter by the object’s `content` field. */
  content?: InputMaybe<JsonFilter>
  /** Filter by the object’s `namespace` field. */
  namespace?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<MetadatumFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MetadatumFilter>>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `target` relation. */
  target?: InputMaybe<EntityFilter>
  /** Filter by the object’s `targetUid` field. */
  targetUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** Information about pagination in a connection. */
export type PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>
}

export type PublicationService = {
  address: Scalars['String']
  /** Reads and enables pagination through a set of `BroadcastEvent`. */
  broadcastEventsByBroadcastService: BroadcastEventsConnection
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupingsByContentItemPublicationServiceUidAndPrimaryGroupingUid: PublicationServiceContentGroupingsByContentItemPublicationServiceUidAndPrimaryGroupingUidManyToManyConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ContentItemsConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItemsByBroadcastEventBroadcastServiceUidAndContentItemUid: PublicationServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidManyToManyConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByContentItemPublicationServiceUidAndLicenseUid: PublicationServiceLicensesByContentItemPublicationServiceUidAndLicenseUidManyToManyConnection
  medium?: Maybe<Scalars['String']>
  name: Scalars['String']
  /** Reads a single `Contributor` that is related to this `PublicationService`. */
  publisher?: Maybe<Contributor>
  publisherUid?: Maybe<Scalars['String']>
  /** Reads a single `Revision` that is related to this `PublicationService`. */
  revision?: Maybe<Revision>
  revisionId: Scalars['String']
  uid: Scalars['String']
}

export type PublicationServiceBroadcastEventsByBroadcastServiceArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastEventCondition>
  filter: InputMaybe<BroadcastEventFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
}

export type PublicationServiceContentGroupingsByContentItemPublicationServiceUidAndPrimaryGroupingUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentGroupingCondition>
    filter: InputMaybe<ContentGroupingFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
  }

export type PublicationServiceContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type PublicationServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

export type PublicationServiceLicensesByContentItemPublicationServiceUidAndLicenseUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<LicenseCondition>
    filter: InputMaybe<LicenseFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<LicensesOrderBy>>
  }

/**
 * A condition to be used against `PublicationService` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PublicationServiceCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `medium` field. */
  medium?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `publisherUid` field. */
  publisherUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentGrouping` values, with data from `ContentItem`. */
export type PublicationServiceContentGroupingsByContentItemPublicationServiceUidAndPrimaryGroupingUidManyToManyConnection =
  {
    /** A list of edges which contains the `ContentGrouping`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<PublicationServiceContentGroupingsByContentItemPublicationServiceUidAndPrimaryGroupingUidManyToManyEdge>
    /** A list of `ContentGrouping` objects. */
    nodes: Array<ContentGrouping>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentGrouping` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentGrouping` edge in the connection, with data from `ContentItem`. */
export type PublicationServiceContentGroupingsByContentItemPublicationServiceUidAndPrimaryGroupingUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItemsByPrimaryGrouping: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `ContentGrouping` at the end of the edge. */
    node: ContentGrouping
  }

/** A `ContentGrouping` edge in the connection, with data from `ContentItem`. */
export type PublicationServiceContentGroupingsByContentItemPublicationServiceUidAndPrimaryGroupingUidManyToManyEdgeContentItemsByPrimaryGroupingArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A connection to a list of `ContentItem` values, with data from `BroadcastEvent`. */
export type PublicationServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `BroadcastEvent`, and the cursor to aid in pagination. */
    edges: Array<PublicationServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `BroadcastEvent`. */
export type PublicationServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `BroadcastEvent`. */
    broadcastEvents: BroadcastEventsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `ContentItem` at the end of the edge. */
    node: ContentItem
  }

/** A `ContentItem` edge in the connection, with data from `BroadcastEvent`. */
export type PublicationServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidManyToManyEdgeBroadcastEventsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastEventCondition>
    filter: InputMaybe<BroadcastEventFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
  }

/** A filter to be used against `PublicationService` object types. All fields are combined with a logical ‘and.’ */
export type PublicationServiceFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PublicationServiceFilter>>
  /** Filter by the object’s `broadcastEventsByBroadcastService` relation. */
  broadcastEventsByBroadcastService?: InputMaybe<PublicationServiceToManyBroadcastEventFilter>
  /** Some related `broadcastEventsByBroadcastService` exist. */
  broadcastEventsByBroadcastServiceExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `contentItems` relation. */
  contentItems?: InputMaybe<PublicationServiceToManyContentItemFilter>
  /** Some related `contentItems` exist. */
  contentItemsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `medium` field. */
  medium?: InputMaybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<PublicationServiceFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PublicationServiceFilter>>
  /** Filter by the object’s `publisher` relation. */
  publisher?: InputMaybe<ContributorFilter>
  /** A related `publisher` exists. */
  publisherExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `publisherUid` field. */
  publisherUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `revision` relation. */
  revision?: InputMaybe<RevisionFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `License` values, with data from `ContentItem`. */
export type PublicationServiceLicensesByContentItemPublicationServiceUidAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<PublicationServiceLicensesByContentItemPublicationServiceUidAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `ContentItem`. */
export type PublicationServiceLicensesByContentItemPublicationServiceUidAndLicenseUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItems: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `ContentItem`. */
export type PublicationServiceLicensesByContentItemPublicationServiceUidAndLicenseUidManyToManyEdgeContentItemsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A filter to be used against many `BroadcastEvent` object types. All fields are combined with a logical ‘and.’ */
export type PublicationServiceToManyBroadcastEventFilter = {
  /** Every related `BroadcastEvent` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<BroadcastEventFilter>
  /** No related `BroadcastEvent` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<BroadcastEventFilter>
  /** Some related `BroadcastEvent` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<BroadcastEventFilter>
}

/** A filter to be used against many `ContentItem` object types. All fields are combined with a logical ‘and.’ */
export type PublicationServiceToManyContentItemFilter = {
  /** Every related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ContentItemFilter>
  /** No related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ContentItemFilter>
  /** Some related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ContentItemFilter>
}

/** A connection to a list of `PublicationService` values. */
export type PublicationServicesConnection = {
  /** A list of edges which contains the `PublicationService` and cursor to aid in pagination. */
  edges: Array<PublicationServicesEdge>
  /** A list of `PublicationService` objects. */
  nodes: Array<PublicationService>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `PublicationService` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `PublicationService` edge in the connection. */
export type PublicationServicesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `PublicationService` at the end of the edge. */
  node: PublicationService
}

/** Methods to use when ordering `PublicationService`. */
export enum PublicationServicesOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  MediumAsc = 'MEDIUM_ASC',
  MediumDesc = 'MEDIUM_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PublisherUidAsc = 'PUBLISHER_UID_ASC',
  PublisherUidDesc = 'PUBLISHER_UID_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

/** The root query type which gives access points into the data universe. */
export type Query = {
  agent?: Maybe<Agent>
  /** Reads and enables pagination through a set of `Agent`. */
  agents?: Maybe<AgentsConnection>
  block?: Maybe<Block>
  /** Reads and enables pagination through a set of `Block`. */
  blocks?: Maybe<BlocksConnection>
  broadcastEvent?: Maybe<BroadcastEvent>
  /** Reads and enables pagination through a set of `BroadcastEvent`. */
  broadcastEvents?: Maybe<BroadcastEventsConnection>
  chapter?: Maybe<Chapter>
  /** Reads and enables pagination through a set of `Chapter`. */
  chapters?: Maybe<ChaptersConnection>
  commit?: Maybe<Commit>
  /** Reads and enables pagination through a set of `Commit`. */
  commits?: Maybe<CommitsConnection>
  concept?: Maybe<Concept>
  /** Reads and enables pagination through a set of `Concept`. */
  concepts?: Maybe<ConceptsConnection>
  contentGrouping?: Maybe<ContentGrouping>
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupings?: Maybe<ContentGroupingsConnection>
  contentItem?: Maybe<ContentItem>
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems?: Maybe<ContentItemsConnection>
  contribution?: Maybe<Contribution>
  /** Reads and enables pagination through a set of `Contribution`. */
  contributions?: Maybe<ContributionsConnection>
  contributor?: Maybe<Contributor>
  /** Reads and enables pagination through a set of `Contributor`. */
  contributors?: Maybe<ContributorsConnection>
  dataSource?: Maybe<DataSource>
  /** Reads and enables pagination through a set of `DataSource`. */
  dataSources?: Maybe<DataSourcesConnection>
  /** Reads and enables pagination through a set of `Entity`. */
  entities?: Maybe<EntitiesConnection>
  entity?: Maybe<Entity>
  failedDatasourceFetch?: Maybe<FailedDatasourceFetch>
  /** Reads and enables pagination through a set of `FailedDatasourceFetch`. */
  failedDatasourceFetches?: Maybe<FailedDatasourceFetchesConnection>
  file?: Maybe<File>
  /** Reads and enables pagination through a set of `File`. */
  files?: Maybe<FilesConnection>
  keypair?: Maybe<Keypair>
  /** Reads and enables pagination through a set of `Keypair`. */
  keypairs?: Maybe<KeypairsConnection>
  license?: Maybe<License>
  /** Reads and enables pagination through a set of `License`. */
  licenses?: Maybe<LicensesConnection>
  mediaAsset?: Maybe<MediaAsset>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets?: Maybe<MediaAssetsConnection>
  /** Reads and enables pagination through a set of `Metadatum`. */
  metadata?: Maybe<MetadataConnection>
  publicationService?: Maybe<PublicationService>
  /** Reads and enables pagination through a set of `PublicationService`. */
  publicationServices?: Maybe<PublicationServicesConnection>
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query
  repo?: Maybe<Repo>
  /** Reads and enables pagination through a set of `Repo`. */
  repos?: Maybe<ReposConnection>
  revision?: Maybe<Revision>
  /** Reads and enables pagination through a set of `Revision`. */
  revisions?: Maybe<RevisionsConnection>
  sourceRecord?: Maybe<SourceRecord>
  /** Reads and enables pagination through a set of `SourceRecord`. */
  sourceRecords?: Maybe<SourceRecordsConnection>
  transcript?: Maybe<Transcript>
  /** Reads and enables pagination through a set of `Transcript`. */
  transcripts?: Maybe<TranscriptsConnection>
  translation?: Maybe<Translation>
  /** Reads and enables pagination through a set of `Translation`. */
  translations?: Maybe<TranslationsConnection>
  ucan?: Maybe<Ucan>
  /** Reads and enables pagination through a set of `Ucan`. */
  ucans?: Maybe<UcansConnection>
  user?: Maybe<User>
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>
}

/** The root query type which gives access points into the data universe. */
export type QueryAgentArgs = {
  did: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryAgentsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<AgentCondition>
  filter: InputMaybe<AgentFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<AgentsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryBlockArgs = {
  cid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryBlocksArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BlockCondition>
  filter: InputMaybe<BlockFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BlocksOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryBroadcastEventArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryBroadcastEventsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastEventCondition>
  filter: InputMaybe<BroadcastEventFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryChapterArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryChaptersArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ChapterCondition>
  filter: InputMaybe<ChapterFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ChaptersOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryCommitArgs = {
  rootCid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryCommitsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryConceptArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryConceptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryContentGroupingArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryContentGroupingsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentGroupingCondition>
  filter: InputMaybe<ContentGroupingFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryContentItemArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryContributionArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryContributionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributionCondition>
  filter: InputMaybe<ContributionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributionsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryContributorArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryContributorsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributorCondition>
  filter: InputMaybe<ContributorFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributorsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryDataSourceArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryDataSourcesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<DataSourceCondition>
  filter: InputMaybe<DataSourceFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<DataSourcesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryEntitiesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<EntityCondition>
  filter: InputMaybe<EntityFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<EntitiesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryEntityArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryFailedDatasourceFetchArgs = {
  datasourceUid: Scalars['String']
  uri: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryFailedDatasourceFetchesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FailedDatasourceFetchCondition>
  filter: InputMaybe<FailedDatasourceFetchFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FailedDatasourceFetchesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryFileArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryFilesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryKeypairArgs = {
  did: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryKeypairsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<KeypairCondition>
  filter: InputMaybe<KeypairFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<KeypairsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryLicenseArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryLicensesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryMediaAssetArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryMetadataArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MetadatumCondition>
  filter: InputMaybe<MetadatumFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MetadataOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryPublicationServiceArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryPublicationServicesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<PublicationServiceCondition>
  filter: InputMaybe<PublicationServiceFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<PublicationServicesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryRepoArgs = {
  did: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryReposArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<RepoCondition>
  filter: InputMaybe<RepoFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ReposOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryRevisionArgs = {
  id: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryRevisionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<RevisionCondition>
  filter: InputMaybe<RevisionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<RevisionsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QuerySourceRecordArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QuerySourceRecordsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<SourceRecordCondition>
  filter: InputMaybe<SourceRecordFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<SourceRecordsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryTranscriptArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryTranscriptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<TranscriptCondition>
  filter: InputMaybe<TranscriptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<TranscriptsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryTranslationArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryTranslationsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<TranslationCondition>
  filter: InputMaybe<TranslationFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<TranslationsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryUcanArgs = {
  cid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryUcansArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<UcanCondition>
  filter: InputMaybe<UcanFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<UcansOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  did: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<UserCondition>
  filter: InputMaybe<UserFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<UsersOrderBy>>
}

export type Repo = {
  /** Reads and enables pagination through a set of `Agent`. */
  agentsByCommitRepoDidAndAgentDid: RepoAgentsByCommitRepoDidAndAgentDidManyToManyConnection
  /** Reads a single `Commit` that is related to this `Repo`. */
  commitByHead?: Maybe<Commit>
  /** Reads and enables pagination through a set of `Commit`. */
  commits: CommitsConnection
  /** Reads and enables pagination through a set of `Commit`. */
  commitsByCommitRepoDidAndParent: RepoCommitsByCommitRepoDidAndParentManyToManyConnection
  did: Scalars['String']
  gateways?: Maybe<Array<Maybe<Scalars['String']>>>
  head?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `Revision`. */
  revisions: RevisionsConnection
  tail?: Maybe<Scalars['String']>
}

export type RepoAgentsByCommitRepoDidAndAgentDidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<AgentCondition>
  filter: InputMaybe<AgentFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<AgentsOrderBy>>
}

export type RepoCommitsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

export type RepoCommitsByCommitRepoDidAndParentArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

export type RepoRevisionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<RevisionCondition>
  filter: InputMaybe<RevisionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<RevisionsOrderBy>>
}

/** A connection to a list of `Agent` values, with data from `Commit`. */
export type RepoAgentsByCommitRepoDidAndAgentDidManyToManyConnection = {
  /** A list of edges which contains the `Agent`, info from the `Commit`, and the cursor to aid in pagination. */
  edges: Array<RepoAgentsByCommitRepoDidAndAgentDidManyToManyEdge>
  /** A list of `Agent` objects. */
  nodes: Array<Agent>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Agent` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Agent` edge in the connection, with data from `Commit`. */
export type RepoAgentsByCommitRepoDidAndAgentDidManyToManyEdge = {
  /** Reads and enables pagination through a set of `Commit`. */
  commits: CommitsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Agent` at the end of the edge. */
  node: Agent
}

/** A `Agent` edge in the connection, with data from `Commit`. */
export type RepoAgentsByCommitRepoDidAndAgentDidManyToManyEdgeCommitsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

/** A connection to a list of `Commit` values, with data from `Commit`. */
export type RepoCommitsByCommitRepoDidAndParentManyToManyConnection = {
  /** A list of edges which contains the `Commit`, info from the `Commit`, and the cursor to aid in pagination. */
  edges: Array<RepoCommitsByCommitRepoDidAndParentManyToManyEdge>
  /** A list of `Commit` objects. */
  nodes: Array<Commit>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Commit` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Commit` edge in the connection, with data from `Commit`. */
export type RepoCommitsByCommitRepoDidAndParentManyToManyEdge = {
  /** Reads and enables pagination through a set of `Commit`. */
  commitsByParent: CommitsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Commit` at the end of the edge. */
  node: Commit
}

/** A `Commit` edge in the connection, with data from `Commit`. */
export type RepoCommitsByCommitRepoDidAndParentManyToManyEdgeCommitsByParentArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<CommitCondition>
    filter: InputMaybe<CommitFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<CommitsOrderBy>>
  }

/** A condition to be used against `Repo` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RepoCondition = {
  /** Checks for equality with the object’s `did` field. */
  did?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `gateways` field. */
  gateways?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Checks for equality with the object’s `head` field. */
  head?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `tail` field. */
  tail?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Repo` object types. All fields are combined with a logical ‘and.’ */
export type RepoFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RepoFilter>>
  /** Filter by the object’s `commitByHead` relation. */
  commitByHead?: InputMaybe<CommitFilter>
  /** A related `commitByHead` exists. */
  commitByHeadExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `commits` relation. */
  commits?: InputMaybe<RepoToManyCommitFilter>
  /** Some related `commits` exist. */
  commitsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `did` field. */
  did?: InputMaybe<StringFilter>
  /** Filter by the object’s `gateways` field. */
  gateways?: InputMaybe<StringListFilter>
  /** Filter by the object’s `head` field. */
  head?: InputMaybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<RepoFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RepoFilter>>
  /** Filter by the object’s `revisions` relation. */
  revisions?: InputMaybe<RepoToManyRevisionFilter>
  /** Some related `revisions` exist. */
  revisionsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `tail` field. */
  tail?: InputMaybe<StringFilter>
}

/** A filter to be used against many `Commit` object types. All fields are combined with a logical ‘and.’ */
export type RepoToManyCommitFilter = {
  /** Every related `Commit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CommitFilter>
  /** No related `Commit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CommitFilter>
  /** Some related `Commit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CommitFilter>
}

/** A filter to be used against many `Revision` object types. All fields are combined with a logical ‘and.’ */
export type RepoToManyRevisionFilter = {
  /** Every related `Revision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RevisionFilter>
  /** No related `Revision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RevisionFilter>
  /** Some related `Revision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RevisionFilter>
}

/** A connection to a list of `Repo` values. */
export type ReposConnection = {
  /** A list of edges which contains the `Repo` and cursor to aid in pagination. */
  edges: Array<ReposEdge>
  /** A list of `Repo` objects. */
  nodes: Array<Repo>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Repo` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Repo` edge in the connection. */
export type ReposEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Repo` at the end of the edge. */
  node: Repo
}

/** Methods to use when ordering `Repo`. */
export enum ReposOrderBy {
  DidAsc = 'DID_ASC',
  DidDesc = 'DID_DESC',
  GatewaysAsc = 'GATEWAYS_ASC',
  GatewaysDesc = 'GATEWAYS_DESC',
  HeadAsc = 'HEAD_ASC',
  HeadDesc = 'HEAD_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TailAsc = 'TAIL_ASC',
  TailDesc = 'TAIL_DESC',
}

export type Revision = {
  /** Reads a single `Agent` that is related to this `Revision`. */
  agent?: Maybe<Agent>
  agentDid: Scalars['String']
  /** Reads and enables pagination through a set of `BroadcastEvent`. */
  broadcastEvents: BroadcastEventsConnection
  /** Reads and enables pagination through a set of `Chapter`. */
  chapters: ChaptersConnection
  /** Reads and enables pagination through a set of `Commit`. */
  commits: RevisionCommitsByRevisionToCommitBAndAManyToManyConnection
  /** Reads and enables pagination through a set of `Concept`. */
  concepts: ConceptsConnection
  /** Reads and enables pagination through a set of `Concept`. */
  conceptsByConceptRevisionIdAndParentUid: RevisionConceptsByConceptRevisionIdAndParentUidManyToManyConnection
  /** Reads and enables pagination through a set of `Concept`. */
  conceptsByConceptRevisionIdAndSameAsUid: RevisionConceptsByConceptRevisionIdAndSameAsUidManyToManyConnection
  contentCid: Scalars['String']
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupings: ContentGroupingsConnection
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupingsByContentItemRevisionIdAndPrimaryGroupingUid: RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidManyToManyConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ContentItemsConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItemsByBroadcastEventRevisionIdAndContentItemUid: RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidManyToManyConnection
  /** Reads and enables pagination through a set of `Contribution`. */
  contributions: ContributionsConnection
  /** Reads and enables pagination through a set of `Contributor`. */
  contributors: ContributorsConnection
  /** Reads and enables pagination through a set of `Contributor`. */
  contributorsByPublicationServiceRevisionIdAndPublisherUid: RevisionContributorsByPublicationServiceRevisionIdAndPublisherUidManyToManyConnection
  dateCreated: Scalars['Datetime']
  dateModified: Scalars['Datetime']
  derivedFromUid?: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `Entity`. */
  entities: EntitiesConnection
  /** Reads and enables pagination through a set of `Entity`. */
  entitiesByMetadatumRevisionIdAndTargetUid: RevisionEntitiesByMetadatumRevisionIdAndTargetUidManyToManyConnection
  entityType: Scalars['String']
  entityUris?: Maybe<Array<Maybe<Scalars['String']>>>
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByContributorRevisionIdAndProfilePictureUid: RevisionFilesByContributorRevisionIdAndProfilePictureUidManyToManyConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetRevisionIdAndFileUid: RevisionFilesByMediaAssetRevisionIdAndFileUidManyToManyConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetRevisionIdAndTeaserImageUid: RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidManyToManyConnection
  id: Scalars['String']
  isDeleted: Scalars['Boolean']
  /** Reads and enables pagination through a set of `License`. */
  licenses: LicensesConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByContentGroupingRevisionIdAndLicenseUid: RevisionLicensesByContentGroupingRevisionIdAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByContentItemRevisionIdAndLicenseUid: RevisionLicensesByContentItemRevisionIdAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByMediaAssetRevisionIdAndLicenseUid: RevisionLicensesByMediaAssetRevisionIdAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssetsByChapterRevisionIdAndMediaAssetUid: RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidManyToManyConnection
  /** Reads and enables pagination through a set of `Metadatum`. */
  metadata: MetadataConnection
  /** Reads a single `Revision` that is related to this `Revision`. */
  prevRevision?: Maybe<Revision>
  prevRevisionId?: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `PublicationService`. */
  publicationServices: PublicationServicesConnection
  /** Reads and enables pagination through a set of `PublicationService`. */
  publicationServicesByBroadcastEventRevisionIdAndBroadcastServiceUid: RevisionPublicationServicesByBroadcastEventRevisionIdAndBroadcastServiceUidManyToManyConnection
  /** Reads and enables pagination through a set of `PublicationService`. */
  publicationServicesByContentItemRevisionIdAndPublicationServiceUid: RevisionPublicationServicesByContentItemRevisionIdAndPublicationServiceUidManyToManyConnection
  /** Reads a single `Repo` that is related to this `Revision`. */
  repo?: Maybe<Repo>
  repoDid: Scalars['String']
  revisionCid: Scalars['String']
  revisionUris?: Maybe<Array<Maybe<Scalars['String']>>>
  /** Reads and enables pagination through a set of `Revision`. */
  revisionsByPrevRevisionId: RevisionsConnection
  uid: Scalars['String']
}

export type RevisionBroadcastEventsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastEventCondition>
  filter: InputMaybe<BroadcastEventFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
}

export type RevisionChaptersArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ChapterCondition>
  filter: InputMaybe<ChapterFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ChaptersOrderBy>>
}

export type RevisionCommitsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<CommitCondition>
  filter: InputMaybe<CommitFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<CommitsOrderBy>>
}

export type RevisionConceptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type RevisionConceptsByConceptRevisionIdAndParentUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type RevisionConceptsByConceptRevisionIdAndSameAsUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type RevisionContentGroupingsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentGroupingCondition>
  filter: InputMaybe<ContentGroupingFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
}

export type RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentGroupingCondition>
    filter: InputMaybe<ContentGroupingFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
  }

export type RevisionContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

export type RevisionContributionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributionCondition>
  filter: InputMaybe<ContributionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributionsOrderBy>>
}

export type RevisionContributorsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributorCondition>
  filter: InputMaybe<ContributorFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributorsOrderBy>>
}

export type RevisionContributorsByPublicationServiceRevisionIdAndPublisherUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContributorCondition>
    filter: InputMaybe<ContributorFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContributorsOrderBy>>
  }

export type RevisionEntitiesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<EntityCondition>
  filter: InputMaybe<EntityFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<EntitiesOrderBy>>
}

export type RevisionEntitiesByMetadatumRevisionIdAndTargetUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<EntityCondition>
  filter: InputMaybe<EntityFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<EntitiesOrderBy>>
}

export type RevisionFilesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type RevisionFilesByContributorRevisionIdAndProfilePictureUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type RevisionFilesByMediaAssetRevisionIdAndFileUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type RevisionLicensesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type RevisionLicensesByContentGroupingRevisionIdAndLicenseUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type RevisionLicensesByContentItemRevisionIdAndLicenseUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type RevisionLicensesByMediaAssetRevisionIdAndLicenseUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type RevisionMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

export type RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

export type RevisionMetadataArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MetadatumCondition>
  filter: InputMaybe<MetadatumFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MetadataOrderBy>>
}

export type RevisionPublicationServicesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<PublicationServiceCondition>
  filter: InputMaybe<PublicationServiceFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<PublicationServicesOrderBy>>
}

export type RevisionPublicationServicesByBroadcastEventRevisionIdAndBroadcastServiceUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<PublicationServiceCondition>
    filter: InputMaybe<PublicationServiceFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<PublicationServicesOrderBy>>
  }

export type RevisionPublicationServicesByContentItemRevisionIdAndPublicationServiceUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<PublicationServiceCondition>
    filter: InputMaybe<PublicationServiceFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<PublicationServicesOrderBy>>
  }

export type RevisionRevisionsByPrevRevisionIdArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<RevisionCondition>
  filter: InputMaybe<RevisionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<RevisionsOrderBy>>
}

/** A connection to a list of `Commit` values, with data from `_RevisionToCommit`. */
export type RevisionCommitsByRevisionToCommitBAndAManyToManyConnection = {
  /** A list of edges which contains the `Commit`, info from the `_RevisionToCommit`, and the cursor to aid in pagination. */
  edges: Array<RevisionCommitsByRevisionToCommitBAndAManyToManyEdge>
  /** A list of `Commit` objects. */
  nodes: Array<Commit>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Commit` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Commit` edge in the connection, with data from `_RevisionToCommit`. */
export type RevisionCommitsByRevisionToCommitBAndAManyToManyEdge = {
  /** Reads and enables pagination through a set of `_RevisionToCommit`. */
  _revisionToCommitsByA: _RevisionToCommitsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Commit` at the end of the edge. */
  node: Commit
}

/** A `Commit` edge in the connection, with data from `_RevisionToCommit`. */
export type RevisionCommitsByRevisionToCommitBAndAManyToManyEdge_RevisionToCommitsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_RevisionToCommitCondition>
    filter: InputMaybe<_RevisionToCommitFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_RevisionToCommitsOrderBy>>
  }

/** A connection to a list of `Concept` values, with data from `Concept`. */
export type RevisionConceptsByConceptRevisionIdAndParentUidManyToManyConnection =
  {
    /** A list of edges which contains the `Concept`, info from the `Concept`, and the cursor to aid in pagination. */
    edges: Array<RevisionConceptsByConceptRevisionIdAndParentUidManyToManyEdge>
    /** A list of `Concept` objects. */
    nodes: Array<Concept>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Concept` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Concept` edge in the connection, with data from `Concept`. */
export type RevisionConceptsByConceptRevisionIdAndParentUidManyToManyEdge = {
  /** Reads and enables pagination through a set of `Concept`. */
  childConcepts: ConceptsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Concept` at the end of the edge. */
  node: Concept
}

/** A `Concept` edge in the connection, with data from `Concept`. */
export type RevisionConceptsByConceptRevisionIdAndParentUidManyToManyEdgeChildConceptsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ConceptCondition>
    filter: InputMaybe<ConceptFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ConceptsOrderBy>>
  }

/** A connection to a list of `Concept` values, with data from `Concept`. */
export type RevisionConceptsByConceptRevisionIdAndSameAsUidManyToManyConnection =
  {
    /** A list of edges which contains the `Concept`, info from the `Concept`, and the cursor to aid in pagination. */
    edges: Array<RevisionConceptsByConceptRevisionIdAndSameAsUidManyToManyEdge>
    /** A list of `Concept` objects. */
    nodes: Array<Concept>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Concept` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Concept` edge in the connection, with data from `Concept`. */
export type RevisionConceptsByConceptRevisionIdAndSameAsUidManyToManyEdge = {
  /** Reads and enables pagination through a set of `Concept`. */
  conceptsBySameAs: ConceptsConnection
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Concept` at the end of the edge. */
  node: Concept
}

/** A `Concept` edge in the connection, with data from `Concept`. */
export type RevisionConceptsByConceptRevisionIdAndSameAsUidManyToManyEdgeConceptsBySameAsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ConceptCondition>
    filter: InputMaybe<ConceptFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ConceptsOrderBy>>
  }

/**
 * A condition to be used against `Revision` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RevisionCondition = {
  /** Checks for equality with the object’s `agentDid` field. */
  agentDid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `contentCid` field. */
  contentCid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `dateCreated` field. */
  dateCreated?: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `dateModified` field. */
  dateModified?: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `derivedFromUid` field. */
  derivedFromUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `entityType` field. */
  entityType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `entityUris` field. */
  entityUris?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `isDeleted` field. */
  isDeleted?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `prevRevisionId` field. */
  prevRevisionId?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `repoDid` field. */
  repoDid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionCid` field. */
  revisionCid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionUris` field. */
  revisionUris?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentGrouping` values, with data from `ContentItem`. */
export type RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidManyToManyConnection =
  {
    /** A list of edges which contains the `ContentGrouping`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidManyToManyEdge>
    /** A list of `ContentGrouping` objects. */
    nodes: Array<ContentGrouping>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentGrouping` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentGrouping` edge in the connection, with data from `ContentItem`. */
export type RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItemsByPrimaryGrouping: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `ContentGrouping` at the end of the edge. */
    node: ContentGrouping
  }

/** A `ContentGrouping` edge in the connection, with data from `ContentItem`. */
export type RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidManyToManyEdgeContentItemsByPrimaryGroupingArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A connection to a list of `ContentItem` values, with data from `BroadcastEvent`. */
export type RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `BroadcastEvent`, and the cursor to aid in pagination. */
    edges: Array<RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `BroadcastEvent`. */
export type RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `BroadcastEvent`. */
    broadcastEvents: BroadcastEventsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `ContentItem` at the end of the edge. */
    node: ContentItem
  }

/** A `ContentItem` edge in the connection, with data from `BroadcastEvent`. */
export type RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidManyToManyEdgeBroadcastEventsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastEventCondition>
    filter: InputMaybe<BroadcastEventFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
  }

/** A connection to a list of `Contributor` values, with data from `PublicationService`. */
export type RevisionContributorsByPublicationServiceRevisionIdAndPublisherUidManyToManyConnection =
  {
    /** A list of edges which contains the `Contributor`, info from the `PublicationService`, and the cursor to aid in pagination. */
    edges: Array<RevisionContributorsByPublicationServiceRevisionIdAndPublisherUidManyToManyEdge>
    /** A list of `Contributor` objects. */
    nodes: Array<Contributor>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Contributor` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Contributor` edge in the connection, with data from `PublicationService`. */
export type RevisionContributorsByPublicationServiceRevisionIdAndPublisherUidManyToManyEdge =
  {
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `Contributor` at the end of the edge. */
    node: Contributor
    /** Reads and enables pagination through a set of `PublicationService`. */
    publicationServicesByPublisher: PublicationServicesConnection
  }

/** A `Contributor` edge in the connection, with data from `PublicationService`. */
export type RevisionContributorsByPublicationServiceRevisionIdAndPublisherUidManyToManyEdgePublicationServicesByPublisherArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<PublicationServiceCondition>
    filter: InputMaybe<PublicationServiceFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<PublicationServicesOrderBy>>
  }

/** A connection to a list of `Entity` values, with data from `Metadatum`. */
export type RevisionEntitiesByMetadatumRevisionIdAndTargetUidManyToManyConnection =
  {
    /** A list of edges which contains the `Entity`, info from the `Metadatum`, and the cursor to aid in pagination. */
    edges: Array<RevisionEntitiesByMetadatumRevisionIdAndTargetUidManyToManyEdge>
    /** A list of `Entity` objects. */
    nodes: Array<Entity>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Entity` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Entity` edge in the connection, with data from `Metadatum`. */
export type RevisionEntitiesByMetadatumRevisionIdAndTargetUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `Metadatum`. */
  metadataByTarget: MetadataConnection
  /** The `Entity` at the end of the edge. */
  node: Entity
}

/** A `Entity` edge in the connection, with data from `Metadatum`. */
export type RevisionEntitiesByMetadatumRevisionIdAndTargetUidManyToManyEdgeMetadataByTargetArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MetadatumCondition>
    filter: InputMaybe<MetadatumFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MetadataOrderBy>>
  }

/** A connection to a list of `File` values, with data from `Contributor`. */
export type RevisionFilesByContributorRevisionIdAndProfilePictureUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `Contributor`, and the cursor to aid in pagination. */
    edges: Array<RevisionFilesByContributorRevisionIdAndProfilePictureUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `Contributor`. */
export type RevisionFilesByContributorRevisionIdAndProfilePictureUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `Contributor`. */
    contributorsByProfilePicture: ContributorsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `File` at the end of the edge. */
    node: File
  }

/** A `File` edge in the connection, with data from `Contributor`. */
export type RevisionFilesByContributorRevisionIdAndProfilePictureUidManyToManyEdgeContributorsByProfilePictureArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContributorCondition>
    filter: InputMaybe<ContributorFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContributorsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndFileUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<RevisionFilesByMediaAssetRevisionIdAndFileUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndFileUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** The `File` at the end of the edge. */
  node: File
}

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndFileUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidManyToManyEdge =
  {
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** Reads and enables pagination through a set of `MediaAsset`. */
    mediaAssetsByTeaserImage: MediaAssetsConnection
    /** The `File` at the end of the edge. */
    node: File
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidManyToManyEdgeMediaAssetsByTeaserImageArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A filter to be used against `Revision` object types. All fields are combined with a logical ‘and.’ */
export type RevisionFilter = {
  /** Filter by the object’s `agent` relation. */
  agent?: InputMaybe<AgentFilter>
  /** Filter by the object’s `agentDid` field. */
  agentDid?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RevisionFilter>>
  /** Filter by the object’s `broadcastEvents` relation. */
  broadcastEvents?: InputMaybe<RevisionToManyBroadcastEventFilter>
  /** Some related `broadcastEvents` exist. */
  broadcastEventsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `chapters` relation. */
  chapters?: InputMaybe<RevisionToManyChapterFilter>
  /** Some related `chapters` exist. */
  chaptersExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `concepts` relation. */
  concepts?: InputMaybe<RevisionToManyConceptFilter>
  /** Some related `concepts` exist. */
  conceptsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `contentCid` field. */
  contentCid?: InputMaybe<StringFilter>
  /** Filter by the object’s `contentGroupings` relation. */
  contentGroupings?: InputMaybe<RevisionToManyContentGroupingFilter>
  /** Some related `contentGroupings` exist. */
  contentGroupingsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `contentItems` relation. */
  contentItems?: InputMaybe<RevisionToManyContentItemFilter>
  /** Some related `contentItems` exist. */
  contentItemsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `contributions` relation. */
  contributions?: InputMaybe<RevisionToManyContributionFilter>
  /** Some related `contributions` exist. */
  contributionsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `contributors` relation. */
  contributors?: InputMaybe<RevisionToManyContributorFilter>
  /** Some related `contributors` exist. */
  contributorsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `dateCreated` field. */
  dateCreated?: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `dateModified` field. */
  dateModified?: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `derivedFromUid` field. */
  derivedFromUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `entities` relation. */
  entities?: InputMaybe<RevisionToManyEntityFilter>
  /** Some related `entities` exist. */
  entitiesExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `entityType` field. */
  entityType?: InputMaybe<StringFilter>
  /** Filter by the object’s `entityUris` field. */
  entityUris?: InputMaybe<StringListFilter>
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<RevisionToManyFileFilter>
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>
  /** Filter by the object’s `isDeleted` field. */
  isDeleted?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `licenses` relation. */
  licenses?: InputMaybe<RevisionToManyLicenseFilter>
  /** Some related `licenses` exist. */
  licensesExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `mediaAssets` relation. */
  mediaAssets?: InputMaybe<RevisionToManyMediaAssetFilter>
  /** Some related `mediaAssets` exist. */
  mediaAssetsExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `metadata` relation. */
  metadata?: InputMaybe<RevisionToManyMetadatumFilter>
  /** Some related `metadata` exist. */
  metadataExist?: InputMaybe<Scalars['Boolean']>
  /** Negates the expression. */
  not?: InputMaybe<RevisionFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RevisionFilter>>
  /** Filter by the object’s `prevRevision` relation. */
  prevRevision?: InputMaybe<RevisionFilter>
  /** A related `prevRevision` exists. */
  prevRevisionExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `prevRevisionId` field. */
  prevRevisionId?: InputMaybe<StringFilter>
  /** Filter by the object’s `publicationServices` relation. */
  publicationServices?: InputMaybe<RevisionToManyPublicationServiceFilter>
  /** Some related `publicationServices` exist. */
  publicationServicesExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `repo` relation. */
  repo?: InputMaybe<RepoFilter>
  /** Filter by the object’s `repoDid` field. */
  repoDid?: InputMaybe<StringFilter>
  /** Filter by the object’s `revisionCid` field. */
  revisionCid?: InputMaybe<StringFilter>
  /** Filter by the object’s `revisionUris` field. */
  revisionUris?: InputMaybe<StringListFilter>
  /** Filter by the object’s `revisionsByPrevRevisionId` relation. */
  revisionsByPrevRevisionId?: InputMaybe<RevisionToManyRevisionFilter>
  /** Some related `revisionsByPrevRevisionId` exist. */
  revisionsByPrevRevisionIdExist?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `License` values, with data from `ContentGrouping`. */
export type RevisionLicensesByContentGroupingRevisionIdAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `ContentGrouping`, and the cursor to aid in pagination. */
    edges: Array<RevisionLicensesByContentGroupingRevisionIdAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `ContentGrouping`. */
export type RevisionLicensesByContentGroupingRevisionIdAndLicenseUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentGrouping`. */
    contentGroupings: ContentGroupingsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `ContentGrouping`. */
export type RevisionLicensesByContentGroupingRevisionIdAndLicenseUidManyToManyEdgeContentGroupingsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentGroupingCondition>
    filter: InputMaybe<ContentGroupingFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
  }

/** A connection to a list of `License` values, with data from `ContentItem`. */
export type RevisionLicensesByContentItemRevisionIdAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<RevisionLicensesByContentItemRevisionIdAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `ContentItem`. */
export type RevisionLicensesByContentItemRevisionIdAndLicenseUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItems: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `ContentItem`. */
export type RevisionLicensesByContentItemRevisionIdAndLicenseUidManyToManyEdgeContentItemsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A connection to a list of `License` values, with data from `MediaAsset`. */
export type RevisionLicensesByMediaAssetRevisionIdAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<RevisionLicensesByMediaAssetRevisionIdAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type RevisionLicensesByMediaAssetRevisionIdAndLicenseUidManyToManyEdge =
  {
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** Reads and enables pagination through a set of `MediaAsset`. */
    mediaAssets: MediaAssetsConnection
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type RevisionLicensesByMediaAssetRevisionIdAndLicenseUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `MediaAsset` values, with data from `Chapter`. */
export type RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidManyToManyConnection =
  {
    /** A list of edges which contains the `MediaAsset`, info from the `Chapter`, and the cursor to aid in pagination. */
    edges: Array<RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidManyToManyEdge>
    /** A list of `MediaAsset` objects. */
    nodes: Array<MediaAsset>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `MediaAsset` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `MediaAsset` edge in the connection, with data from `Chapter`. */
export type RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `Chapter`. */
    chapters: ChaptersConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `MediaAsset` at the end of the edge. */
    node: MediaAsset
  }

/** A `MediaAsset` edge in the connection, with data from `Chapter`. */
export type RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidManyToManyEdgeChaptersArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ChapterCondition>
    filter: InputMaybe<ChapterFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ChaptersOrderBy>>
  }

/** A connection to a list of `PublicationService` values, with data from `BroadcastEvent`. */
export type RevisionPublicationServicesByBroadcastEventRevisionIdAndBroadcastServiceUidManyToManyConnection =
  {
    /** A list of edges which contains the `PublicationService`, info from the `BroadcastEvent`, and the cursor to aid in pagination. */
    edges: Array<RevisionPublicationServicesByBroadcastEventRevisionIdAndBroadcastServiceUidManyToManyEdge>
    /** A list of `PublicationService` objects. */
    nodes: Array<PublicationService>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `PublicationService` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `PublicationService` edge in the connection, with data from `BroadcastEvent`. */
export type RevisionPublicationServicesByBroadcastEventRevisionIdAndBroadcastServiceUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `BroadcastEvent`. */
    broadcastEventsByBroadcastService: BroadcastEventsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `PublicationService` at the end of the edge. */
    node: PublicationService
  }

/** A `PublicationService` edge in the connection, with data from `BroadcastEvent`. */
export type RevisionPublicationServicesByBroadcastEventRevisionIdAndBroadcastServiceUidManyToManyEdgeBroadcastEventsByBroadcastServiceArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastEventCondition>
    filter: InputMaybe<BroadcastEventFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
  }

/** A connection to a list of `PublicationService` values, with data from `ContentItem`. */
export type RevisionPublicationServicesByContentItemRevisionIdAndPublicationServiceUidManyToManyConnection =
  {
    /** A list of edges which contains the `PublicationService`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<RevisionPublicationServicesByContentItemRevisionIdAndPublicationServiceUidManyToManyEdge>
    /** A list of `PublicationService` objects. */
    nodes: Array<PublicationService>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `PublicationService` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `PublicationService` edge in the connection, with data from `ContentItem`. */
export type RevisionPublicationServicesByContentItemRevisionIdAndPublicationServiceUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItems: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>
    /** The `PublicationService` at the end of the edge. */
    node: PublicationService
  }

/** A `PublicationService` edge in the connection, with data from `ContentItem`. */
export type RevisionPublicationServicesByContentItemRevisionIdAndPublicationServiceUidManyToManyEdgeContentItemsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A filter to be used against many `BroadcastEvent` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyBroadcastEventFilter = {
  /** Every related `BroadcastEvent` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<BroadcastEventFilter>
  /** No related `BroadcastEvent` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<BroadcastEventFilter>
  /** Some related `BroadcastEvent` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<BroadcastEventFilter>
}

/** A filter to be used against many `Chapter` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyChapterFilter = {
  /** Every related `Chapter` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ChapterFilter>
  /** No related `Chapter` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ChapterFilter>
  /** Some related `Chapter` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ChapterFilter>
}

/** A filter to be used against many `Concept` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyConceptFilter = {
  /** Every related `Concept` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ConceptFilter>
  /** No related `Concept` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ConceptFilter>
  /** Some related `Concept` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ConceptFilter>
}

/** A filter to be used against many `ContentGrouping` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyContentGroupingFilter = {
  /** Every related `ContentGrouping` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ContentGroupingFilter>
  /** No related `ContentGrouping` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ContentGroupingFilter>
  /** Some related `ContentGrouping` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ContentGroupingFilter>
}

/** A filter to be used against many `ContentItem` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyContentItemFilter = {
  /** Every related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ContentItemFilter>
  /** No related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ContentItemFilter>
  /** Some related `ContentItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ContentItemFilter>
}

/** A filter to be used against many `Contribution` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyContributionFilter = {
  /** Every related `Contribution` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ContributionFilter>
  /** No related `Contribution` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ContributionFilter>
  /** Some related `Contribution` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ContributionFilter>
}

/** A filter to be used against many `Contributor` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyContributorFilter = {
  /** Every related `Contributor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ContributorFilter>
  /** No related `Contributor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ContributorFilter>
  /** Some related `Contributor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ContributorFilter>
}

/** A filter to be used against many `Entity` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyEntityFilter = {
  /** Every related `Entity` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EntityFilter>
  /** No related `Entity` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EntityFilter>
  /** Some related `Entity` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EntityFilter>
}

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>
}

/** A filter to be used against many `License` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyLicenseFilter = {
  /** Every related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseFilter>
  /** No related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseFilter>
  /** Some related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseFilter>
}

/** A filter to be used against many `MediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyMediaAssetFilter = {
  /** Every related `MediaAsset` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MediaAssetFilter>
  /** No related `MediaAsset` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MediaAssetFilter>
  /** Some related `MediaAsset` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MediaAssetFilter>
}

/** A filter to be used against many `Metadatum` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyMetadatumFilter = {
  /** Every related `Metadatum` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MetadatumFilter>
  /** No related `Metadatum` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MetadatumFilter>
  /** Some related `Metadatum` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MetadatumFilter>
}

/** A filter to be used against many `PublicationService` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyPublicationServiceFilter = {
  /** Every related `PublicationService` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PublicationServiceFilter>
  /** No related `PublicationService` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PublicationServiceFilter>
  /** Some related `PublicationService` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PublicationServiceFilter>
}

/** A filter to be used against many `Revision` object types. All fields are combined with a logical ‘and.’ */
export type RevisionToManyRevisionFilter = {
  /** Every related `Revision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RevisionFilter>
  /** No related `Revision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RevisionFilter>
  /** Some related `Revision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RevisionFilter>
}

/** A connection to a list of `Revision` values. */
export type RevisionsConnection = {
  /** A list of edges which contains the `Revision` and cursor to aid in pagination. */
  edges: Array<RevisionsEdge>
  /** A list of `Revision` objects. */
  nodes: Array<Revision>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Revision` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Revision` edge in the connection. */
export type RevisionsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Revision` at the end of the edge. */
  node: Revision
}

/** Methods to use when ordering `Revision`. */
export enum RevisionsOrderBy {
  AgentDidAsc = 'AGENT_DID_ASC',
  AgentDidDesc = 'AGENT_DID_DESC',
  ContentCidAsc = 'CONTENT_CID_ASC',
  ContentCidDesc = 'CONTENT_CID_DESC',
  DateCreatedAsc = 'DATE_CREATED_ASC',
  DateCreatedDesc = 'DATE_CREATED_DESC',
  DateModifiedAsc = 'DATE_MODIFIED_ASC',
  DateModifiedDesc = 'DATE_MODIFIED_DESC',
  DerivedFromUidAsc = 'DERIVED_FROM_UID_ASC',
  DerivedFromUidDesc = 'DERIVED_FROM_UID_DESC',
  EntityTypeAsc = 'ENTITY_TYPE_ASC',
  EntityTypeDesc = 'ENTITY_TYPE_DESC',
  EntityUrisAsc = 'ENTITY_URIS_ASC',
  EntityUrisDesc = 'ENTITY_URIS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsDeletedAsc = 'IS_DELETED_ASC',
  IsDeletedDesc = 'IS_DELETED_DESC',
  Natural = 'NATURAL',
  PrevRevisionIdAsc = 'PREV_REVISION_ID_ASC',
  PrevRevisionIdDesc = 'PREV_REVISION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RepoDidAsc = 'REPO_DID_ASC',
  RepoDidDesc = 'REPO_DID_DESC',
  RevisionCidAsc = 'REVISION_CID_ASC',
  RevisionCidDesc = 'REVISION_CID_DESC',
  RevisionUrisAsc = 'REVISION_URIS_ASC',
  RevisionUrisDesc = 'REVISION_URIS_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type SourceRecord = {
  body: Scalars['String']
  containedEntityUris?: Maybe<Array<Maybe<Scalars['String']>>>
  contentType: Scalars['String']
  /** Reads a single `DataSource` that is related to this `SourceRecord`. */
  dataSource?: Maybe<DataSource>
  dataSourceUid?: Maybe<Scalars['String']>
  meta?: Maybe<Scalars['JSON']>
  sourceType: Scalars['String']
  sourceUri: Scalars['String']
  timestamp: Scalars['Datetime']
  uid: Scalars['String']
}

/**
 * A condition to be used against `SourceRecord` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SourceRecordCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `containedEntityUris` field. */
  containedEntityUris?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Checks for equality with the object’s `contentType` field. */
  contentType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `dataSourceUid` field. */
  dataSourceUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `meta` field. */
  meta?: InputMaybe<Scalars['JSON']>
  /** Checks for equality with the object’s `sourceType` field. */
  sourceType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `sourceUri` field. */
  sourceUri?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `SourceRecord` object types. All fields are combined with a logical ‘and.’ */
export type SourceRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SourceRecordFilter>>
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>
  /** Filter by the object’s `containedEntityUris` field. */
  containedEntityUris?: InputMaybe<StringListFilter>
  /** Filter by the object’s `contentType` field. */
  contentType?: InputMaybe<StringFilter>
  /** Filter by the object’s `dataSource` relation. */
  dataSource?: InputMaybe<DataSourceFilter>
  /** A related `dataSource` exists. */
  dataSourceExists?: InputMaybe<Scalars['Boolean']>
  /** Filter by the object’s `dataSourceUid` field. */
  dataSourceUid?: InputMaybe<StringFilter>
  /** Filter by the object’s `meta` field. */
  meta?: InputMaybe<JsonFilter>
  /** Negates the expression. */
  not?: InputMaybe<SourceRecordFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SourceRecordFilter>>
  /** Filter by the object’s `sourceType` field. */
  sourceType?: InputMaybe<StringFilter>
  /** Filter by the object’s `sourceUri` field. */
  sourceUri?: InputMaybe<StringFilter>
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `SourceRecord` values. */
export type SourceRecordsConnection = {
  /** A list of edges which contains the `SourceRecord` and cursor to aid in pagination. */
  edges: Array<SourceRecordsEdge>
  /** A list of `SourceRecord` objects. */
  nodes: Array<SourceRecord>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `SourceRecord` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `SourceRecord` edge in the connection. */
export type SourceRecordsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `SourceRecord` at the end of the edge. */
  node: SourceRecord
}

/** Methods to use when ordering `SourceRecord`. */
export enum SourceRecordsOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  ContainedEntityUrisAsc = 'CONTAINED_ENTITY_URIS_ASC',
  ContainedEntityUrisDesc = 'CONTAINED_ENTITY_URIS_DESC',
  ContentTypeAsc = 'CONTENT_TYPE_ASC',
  ContentTypeDesc = 'CONTENT_TYPE_DESC',
  DataSourceUidAsc = 'DATA_SOURCE_UID_ASC',
  DataSourceUidDesc = 'DATA_SOURCE_UID_DESC',
  MetaAsc = 'META_ASC',
  MetaDesc = 'META_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SourceTypeAsc = 'SOURCE_TYPE_ASC',
  SourceTypeDesc = 'SOURCE_TYPE_DESC',
  SourceUriAsc = 'SOURCE_URI_ASC',
  SourceUriDesc = 'SOURCE_URI_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']>
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']>
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']>
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']>
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']>
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']>
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']>>
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']>>
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']>
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']>
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']>
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']>
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']>
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']>
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']>
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']>
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']>
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']>>
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']>>
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']>
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']>
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']>
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']>
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']>
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']>
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']>
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']>
}

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Scalars['String']>
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Scalars['String']>
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Scalars['String']>
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Scalars['String']>
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Scalars['String']>
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Scalars['String']>
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Transcript = {
  engine: Scalars['String']
  language: Scalars['String']
  /** Reads a single `MediaAsset` that is related to this `Transcript`. */
  mediaAsset?: Maybe<MediaAsset>
  mediaAssetUid: Scalars['String']
  text: Scalars['String']
  uid: Scalars['String']
}

/**
 * A condition to be used against `Transcript` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TranscriptCondition = {
  /** Checks for equality with the object’s `engine` field. */
  engine?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `language` field. */
  language?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `mediaAssetUid` field. */
  mediaAssetUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `text` field. */
  text?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Transcript` object types. All fields are combined with a logical ‘and.’ */
export type TranscriptFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TranscriptFilter>>
  /** Filter by the object’s `engine` field. */
  engine?: InputMaybe<StringFilter>
  /** Filter by the object’s `language` field. */
  language?: InputMaybe<StringFilter>
  /** Filter by the object’s `mediaAsset` relation. */
  mediaAsset?: InputMaybe<MediaAssetFilter>
  /** Filter by the object’s `mediaAssetUid` field. */
  mediaAssetUid?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<TranscriptFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TranscriptFilter>>
  /** Filter by the object’s `text` field. */
  text?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `Transcript` values. */
export type TranscriptsConnection = {
  /** A list of edges which contains the `Transcript` and cursor to aid in pagination. */
  edges: Array<TranscriptsEdge>
  /** A list of `Transcript` objects. */
  nodes: Array<Transcript>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Transcript` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Transcript` edge in the connection. */
export type TranscriptsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Transcript` at the end of the edge. */
  node: Transcript
}

/** Methods to use when ordering `Transcript`. */
export enum TranscriptsOrderBy {
  EngineAsc = 'ENGINE_ASC',
  EngineDesc = 'ENGINE_DESC',
  LanguageAsc = 'LANGUAGE_ASC',
  LanguageDesc = 'LANGUAGE_DESC',
  MediaAssetUidAsc = 'MEDIA_ASSET_UID_ASC',
  MediaAssetUidDesc = 'MEDIA_ASSET_UID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TextAsc = 'TEXT_ASC',
  TextDesc = 'TEXT_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Translation = {
  engine: Scalars['String']
  language: Scalars['String']
  /** Reads a single `MediaAsset` that is related to this `Translation`. */
  mediaAsset?: Maybe<MediaAsset>
  mediaAssetUid: Scalars['String']
  text: Scalars['String']
  uid: Scalars['String']
}

/**
 * A condition to be used against `Translation` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TranslationCondition = {
  /** Checks for equality with the object’s `engine` field. */
  engine?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `language` field. */
  language?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `mediaAssetUid` field. */
  mediaAssetUid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `text` field. */
  text?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Translation` object types. All fields are combined with a logical ‘and.’ */
export type TranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TranslationFilter>>
  /** Filter by the object’s `engine` field. */
  engine?: InputMaybe<StringFilter>
  /** Filter by the object’s `language` field. */
  language?: InputMaybe<StringFilter>
  /** Filter by the object’s `mediaAsset` relation. */
  mediaAsset?: InputMaybe<MediaAssetFilter>
  /** Filter by the object’s `mediaAssetUid` field. */
  mediaAssetUid?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<TranslationFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TranslationFilter>>
  /** Filter by the object’s `text` field. */
  text?: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid?: InputMaybe<StringFilter>
}

/** A connection to a list of `Translation` values. */
export type TranslationsConnection = {
  /** A list of edges which contains the `Translation` and cursor to aid in pagination. */
  edges: Array<TranslationsEdge>
  /** A list of `Translation` objects. */
  nodes: Array<Translation>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Translation` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Translation` edge in the connection. */
export type TranslationsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Translation` at the end of the edge. */
  node: Translation
}

/** Methods to use when ordering `Translation`. */
export enum TranslationsOrderBy {
  EngineAsc = 'ENGINE_ASC',
  EngineDesc = 'ENGINE_DESC',
  LanguageAsc = 'LANGUAGE_ASC',
  LanguageDesc = 'LANGUAGE_DESC',
  MediaAssetUidAsc = 'MEDIA_ASSET_UID_ASC',
  MediaAssetUidDesc = 'MEDIA_ASSET_UID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TextAsc = 'TEXT_ASC',
  TextDesc = 'TEXT_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Ucan = {
  audience: Scalars['String']
  cid: Scalars['String']
  resource: Scalars['String']
  scope: Scalars['String']
  token: Scalars['String']
}

/** A condition to be used against `Ucan` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UcanCondition = {
  /** Checks for equality with the object’s `audience` field. */
  audience?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `cid` field. */
  cid?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `resource` field. */
  resource?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `scope` field. */
  scope?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `token` field. */
  token?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Ucan` object types. All fields are combined with a logical ‘and.’ */
export type UcanFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UcanFilter>>
  /** Filter by the object’s `audience` field. */
  audience?: InputMaybe<StringFilter>
  /** Filter by the object’s `cid` field. */
  cid?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<UcanFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UcanFilter>>
  /** Filter by the object’s `resource` field. */
  resource?: InputMaybe<StringFilter>
  /** Filter by the object’s `scope` field. */
  scope?: InputMaybe<StringFilter>
  /** Filter by the object’s `token` field. */
  token?: InputMaybe<StringFilter>
}

/** A connection to a list of `Ucan` values. */
export type UcansConnection = {
  /** A list of edges which contains the `Ucan` and cursor to aid in pagination. */
  edges: Array<UcansEdge>
  /** A list of `Ucan` objects. */
  nodes: Array<Ucan>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Ucan` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Ucan` edge in the connection. */
export type UcansEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Ucan` at the end of the edge. */
  node: Ucan
}

/** Methods to use when ordering `Ucan`. */
export enum UcansOrderBy {
  AudienceAsc = 'AUDIENCE_ASC',
  AudienceDesc = 'AUDIENCE_DESC',
  CidAsc = 'CID_ASC',
  CidDesc = 'CID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ResourceAsc = 'RESOURCE_ASC',
  ResourceDesc = 'RESOURCE_DESC',
  ScopeAsc = 'SCOPE_ASC',
  ScopeDesc = 'SCOPE_DESC',
  TokenAsc = 'TOKEN_ASC',
  TokenDesc = 'TOKEN_DESC',
}

export type User = {
  /** Reads a single `Agent` that is related to this `User`. */
  agentByDid?: Maybe<Agent>
  did: Scalars['String']
  name: Scalars['String']
}

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `did` field. */
  did?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Filter by the object’s `agentByDid` relation. */
  agentByDid?: InputMaybe<AgentFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>
  /** Filter by the object’s `did` field. */
  did?: InputMaybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>
}

/** A connection to a list of `User` values. */
export type UsersConnection = {
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>
  /** A list of `User` objects. */
  nodes: Array<User>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `User` edge in the connection. */
export type UsersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `User` at the end of the edge. */
  node: User
}

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  DidAsc = 'DID_ASC',
  DidDesc = 'DID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type _ConceptToContentItem = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `Concept` that is related to this `_ConceptToContentItem`. */
  conceptByA?: Maybe<Concept>
  /** Reads a single `ContentItem` that is related to this `_ConceptToContentItem`. */
  contentItemByB?: Maybe<ContentItem>
}

/**
 * A condition to be used against `_ConceptToContentItem` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type _ConceptToContentItemCondition = {
  /** Checks for equality with the object’s `a` field. */
  a?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ConceptToContentItem` object types. All fields are combined with a logical ‘and.’ */
export type _ConceptToContentItemFilter = {
  /** Filter by the object’s `a` field. */
  a?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<_ConceptToContentItemFilter>>
  /** Filter by the object’s `b` field. */
  b?: InputMaybe<StringFilter>
  /** Filter by the object’s `conceptByA` relation. */
  conceptByA?: InputMaybe<ConceptFilter>
  /** Filter by the object’s `contentItemByB` relation. */
  contentItemByB?: InputMaybe<ContentItemFilter>
  /** Negates the expression. */
  not?: InputMaybe<_ConceptToContentItemFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<_ConceptToContentItemFilter>>
}

/** A connection to a list of `_ConceptToContentItem` values. */
export type _ConceptToContentItemsConnection = {
  /** A list of edges which contains the `_ConceptToContentItem` and cursor to aid in pagination. */
  edges: Array<_ConceptToContentItemsEdge>
  /** A list of `_ConceptToContentItem` objects. */
  nodes: Array<_ConceptToContentItem>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ConceptToContentItem` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ConceptToContentItem` edge in the connection. */
export type _ConceptToContentItemsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `_ConceptToContentItem` at the end of the edge. */
  node: _ConceptToContentItem
}

/** Methods to use when ordering `_ConceptToContentItem`. */
export enum _ConceptToContentItemsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ConceptToMediaAsset = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `Concept` that is related to this `_ConceptToMediaAsset`. */
  conceptByA?: Maybe<Concept>
  /** Reads a single `MediaAsset` that is related to this `_ConceptToMediaAsset`. */
  mediaAssetByB?: Maybe<MediaAsset>
}

/**
 * A condition to be used against `_ConceptToMediaAsset` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type _ConceptToMediaAssetCondition = {
  /** Checks for equality with the object’s `a` field. */
  a?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ConceptToMediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type _ConceptToMediaAssetFilter = {
  /** Filter by the object’s `a` field. */
  a?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<_ConceptToMediaAssetFilter>>
  /** Filter by the object’s `b` field. */
  b?: InputMaybe<StringFilter>
  /** Filter by the object’s `conceptByA` relation. */
  conceptByA?: InputMaybe<ConceptFilter>
  /** Filter by the object’s `mediaAssetByB` relation. */
  mediaAssetByB?: InputMaybe<MediaAssetFilter>
  /** Negates the expression. */
  not?: InputMaybe<_ConceptToMediaAssetFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<_ConceptToMediaAssetFilter>>
}

/** A connection to a list of `_ConceptToMediaAsset` values. */
export type _ConceptToMediaAssetsConnection = {
  /** A list of edges which contains the `_ConceptToMediaAsset` and cursor to aid in pagination. */
  edges: Array<_ConceptToMediaAssetsEdge>
  /** A list of `_ConceptToMediaAsset` objects. */
  nodes: Array<_ConceptToMediaAsset>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ConceptToMediaAsset` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ConceptToMediaAsset` edge in the connection. */
export type _ConceptToMediaAssetsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `_ConceptToMediaAsset` at the end of the edge. */
  node: _ConceptToMediaAsset
}

/** Methods to use when ordering `_ConceptToMediaAsset`. */
export enum _ConceptToMediaAssetsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ContentGroupingToContentItem = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `ContentGrouping` that is related to this `_ContentGroupingToContentItem`. */
  contentGroupingByA?: Maybe<ContentGrouping>
  /** Reads a single `ContentItem` that is related to this `_ContentGroupingToContentItem`. */
  contentItemByB?: Maybe<ContentItem>
}

/**
 * A condition to be used against `_ContentGroupingToContentItem` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type _ContentGroupingToContentItemCondition = {
  /** Checks for equality with the object’s `a` field. */
  a?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ContentGroupingToContentItem` object types. All fields are combined with a logical ‘and.’ */
export type _ContentGroupingToContentItemFilter = {
  /** Filter by the object’s `a` field. */
  a?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<_ContentGroupingToContentItemFilter>>
  /** Filter by the object’s `b` field. */
  b?: InputMaybe<StringFilter>
  /** Filter by the object’s `contentGroupingByA` relation. */
  contentGroupingByA?: InputMaybe<ContentGroupingFilter>
  /** Filter by the object’s `contentItemByB` relation. */
  contentItemByB?: InputMaybe<ContentItemFilter>
  /** Negates the expression. */
  not?: InputMaybe<_ContentGroupingToContentItemFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<_ContentGroupingToContentItemFilter>>
}

/** A connection to a list of `_ContentGroupingToContentItem` values. */
export type _ContentGroupingToContentItemsConnection = {
  /** A list of edges which contains the `_ContentGroupingToContentItem` and cursor to aid in pagination. */
  edges: Array<_ContentGroupingToContentItemsEdge>
  /** A list of `_ContentGroupingToContentItem` objects. */
  nodes: Array<_ContentGroupingToContentItem>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ContentGroupingToContentItem` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ContentGroupingToContentItem` edge in the connection. */
export type _ContentGroupingToContentItemsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `_ContentGroupingToContentItem` at the end of the edge. */
  node: _ContentGroupingToContentItem
}

/** Methods to use when ordering `_ContentGroupingToContentItem`. */
export enum _ContentGroupingToContentItemsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ContentItemToContribution = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `ContentItem` that is related to this `_ContentItemToContribution`. */
  contentItemByA?: Maybe<ContentItem>
  /** Reads a single `Contribution` that is related to this `_ContentItemToContribution`. */
  contributionByB?: Maybe<Contribution>
}

/**
 * A condition to be used against `_ContentItemToContribution` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type _ContentItemToContributionCondition = {
  /** Checks for equality with the object’s `a` field. */
  a?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ContentItemToContribution` object types. All fields are combined with a logical ‘and.’ */
export type _ContentItemToContributionFilter = {
  /** Filter by the object’s `a` field. */
  a?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<_ContentItemToContributionFilter>>
  /** Filter by the object’s `b` field. */
  b?: InputMaybe<StringFilter>
  /** Filter by the object’s `contentItemByA` relation. */
  contentItemByA?: InputMaybe<ContentItemFilter>
  /** Filter by the object’s `contributionByB` relation. */
  contributionByB?: InputMaybe<ContributionFilter>
  /** Negates the expression. */
  not?: InputMaybe<_ContentItemToContributionFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<_ContentItemToContributionFilter>>
}

/** A connection to a list of `_ContentItemToContribution` values. */
export type _ContentItemToContributionsConnection = {
  /** A list of edges which contains the `_ContentItemToContribution` and cursor to aid in pagination. */
  edges: Array<_ContentItemToContributionsEdge>
  /** A list of `_ContentItemToContribution` objects. */
  nodes: Array<_ContentItemToContribution>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ContentItemToContribution` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ContentItemToContribution` edge in the connection. */
export type _ContentItemToContributionsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `_ContentItemToContribution` at the end of the edge. */
  node: _ContentItemToContribution
}

/** Methods to use when ordering `_ContentItemToContribution`. */
export enum _ContentItemToContributionsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ContentItemToMediaAsset = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `ContentItem` that is related to this `_ContentItemToMediaAsset`. */
  contentItemByA?: Maybe<ContentItem>
  /** Reads a single `MediaAsset` that is related to this `_ContentItemToMediaAsset`. */
  mediaAssetByB?: Maybe<MediaAsset>
}

/**
 * A condition to be used against `_ContentItemToMediaAsset` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type _ContentItemToMediaAssetCondition = {
  /** Checks for equality with the object’s `a` field. */
  a?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ContentItemToMediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type _ContentItemToMediaAssetFilter = {
  /** Filter by the object’s `a` field. */
  a?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<_ContentItemToMediaAssetFilter>>
  /** Filter by the object’s `b` field. */
  b?: InputMaybe<StringFilter>
  /** Filter by the object’s `contentItemByA` relation. */
  contentItemByA?: InputMaybe<ContentItemFilter>
  /** Filter by the object’s `mediaAssetByB` relation. */
  mediaAssetByB?: InputMaybe<MediaAssetFilter>
  /** Negates the expression. */
  not?: InputMaybe<_ContentItemToMediaAssetFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<_ContentItemToMediaAssetFilter>>
}

/** A connection to a list of `_ContentItemToMediaAsset` values. */
export type _ContentItemToMediaAssetsConnection = {
  /** A list of edges which contains the `_ContentItemToMediaAsset` and cursor to aid in pagination. */
  edges: Array<_ContentItemToMediaAssetsEdge>
  /** A list of `_ContentItemToMediaAsset` objects. */
  nodes: Array<_ContentItemToMediaAsset>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ContentItemToMediaAsset` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ContentItemToMediaAsset` edge in the connection. */
export type _ContentItemToMediaAssetsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `_ContentItemToMediaAsset` at the end of the edge. */
  node: _ContentItemToMediaAsset
}

/** Methods to use when ordering `_ContentItemToMediaAsset`. */
export enum _ContentItemToMediaAssetsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ContributionToContributor = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `Contribution` that is related to this `_ContributionToContributor`. */
  contributionByA?: Maybe<Contribution>
  /** Reads a single `Contributor` that is related to this `_ContributionToContributor`. */
  contributorByB?: Maybe<Contributor>
}

/**
 * A condition to be used against `_ContributionToContributor` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type _ContributionToContributorCondition = {
  /** Checks for equality with the object’s `a` field. */
  a?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ContributionToContributor` object types. All fields are combined with a logical ‘and.’ */
export type _ContributionToContributorFilter = {
  /** Filter by the object’s `a` field. */
  a?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<_ContributionToContributorFilter>>
  /** Filter by the object’s `b` field. */
  b?: InputMaybe<StringFilter>
  /** Filter by the object’s `contributionByA` relation. */
  contributionByA?: InputMaybe<ContributionFilter>
  /** Filter by the object’s `contributorByB` relation. */
  contributorByB?: InputMaybe<ContributorFilter>
  /** Negates the expression. */
  not?: InputMaybe<_ContributionToContributorFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<_ContributionToContributorFilter>>
}

/** A connection to a list of `_ContributionToContributor` values. */
export type _ContributionToContributorsConnection = {
  /** A list of edges which contains the `_ContributionToContributor` and cursor to aid in pagination. */
  edges: Array<_ContributionToContributorsEdge>
  /** A list of `_ContributionToContributor` objects. */
  nodes: Array<_ContributionToContributor>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ContributionToContributor` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ContributionToContributor` edge in the connection. */
export type _ContributionToContributorsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `_ContributionToContributor` at the end of the edge. */
  node: _ContributionToContributor
}

/** Methods to use when ordering `_ContributionToContributor`. */
export enum _ContributionToContributorsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ContributionToMediaAsset = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `Contribution` that is related to this `_ContributionToMediaAsset`. */
  contributionByA?: Maybe<Contribution>
  /** Reads a single `MediaAsset` that is related to this `_ContributionToMediaAsset`. */
  mediaAssetByB?: Maybe<MediaAsset>
}

/**
 * A condition to be used against `_ContributionToMediaAsset` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type _ContributionToMediaAssetCondition = {
  /** Checks for equality with the object’s `a` field. */
  a?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ContributionToMediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type _ContributionToMediaAssetFilter = {
  /** Filter by the object’s `a` field. */
  a?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<_ContributionToMediaAssetFilter>>
  /** Filter by the object’s `b` field. */
  b?: InputMaybe<StringFilter>
  /** Filter by the object’s `contributionByA` relation. */
  contributionByA?: InputMaybe<ContributionFilter>
  /** Filter by the object’s `mediaAssetByB` relation. */
  mediaAssetByB?: InputMaybe<MediaAssetFilter>
  /** Negates the expression. */
  not?: InputMaybe<_ContributionToMediaAssetFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<_ContributionToMediaAssetFilter>>
}

/** A connection to a list of `_ContributionToMediaAsset` values. */
export type _ContributionToMediaAssetsConnection = {
  /** A list of edges which contains the `_ContributionToMediaAsset` and cursor to aid in pagination. */
  edges: Array<_ContributionToMediaAssetsEdge>
  /** A list of `_ContributionToMediaAsset` objects. */
  nodes: Array<_ContributionToMediaAsset>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ContributionToMediaAsset` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ContributionToMediaAsset` edge in the connection. */
export type _ContributionToMediaAssetsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `_ContributionToMediaAsset` at the end of the edge. */
  node: _ContributionToMediaAsset
}

/** Methods to use when ordering `_ContributionToMediaAsset`. */
export enum _ContributionToMediaAssetsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _RevisionToCommit = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `Commit` that is related to this `_RevisionToCommit`. */
  commitByA?: Maybe<Commit>
  /** Reads a single `Revision` that is related to this `_RevisionToCommit`. */
  revisionByB?: Maybe<Revision>
}

/**
 * A condition to be used against `_RevisionToCommit` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type _RevisionToCommitCondition = {
  /** Checks for equality with the object’s `a` field. */
  a?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_RevisionToCommit` object types. All fields are combined with a logical ‘and.’ */
export type _RevisionToCommitFilter = {
  /** Filter by the object’s `a` field. */
  a?: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<_RevisionToCommitFilter>>
  /** Filter by the object’s `b` field. */
  b?: InputMaybe<StringFilter>
  /** Filter by the object’s `commitByA` relation. */
  commitByA?: InputMaybe<CommitFilter>
  /** Negates the expression. */
  not?: InputMaybe<_RevisionToCommitFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<_RevisionToCommitFilter>>
  /** Filter by the object’s `revisionByB` relation. */
  revisionByB?: InputMaybe<RevisionFilter>
}

/** A connection to a list of `_RevisionToCommit` values. */
export type _RevisionToCommitsConnection = {
  /** A list of edges which contains the `_RevisionToCommit` and cursor to aid in pagination. */
  edges: Array<_RevisionToCommitsEdge>
  /** A list of `_RevisionToCommit` objects. */
  nodes: Array<_RevisionToCommit>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_RevisionToCommit` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_RevisionToCommit` edge in the connection. */
export type _RevisionToCommitsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `_RevisionToCommit` at the end of the edge. */
  node: _RevisionToCommit
}

/** Methods to use when ordering `_RevisionToCommit`. */
export enum _RevisionToCommitsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type LoadContentItemQueryVariables = Exact<{
  uid: Scalars['String']
}>

export type LoadContentItemQuery = {
  contentItem?: {
    title: string
    uid: string
    content: string
    revisionId: string
    mediaAssets: {
      nodes: Array<{
        uid: string
        mediaType: string
        title: string
        duration?: number | null
        file?: { uid: string; contentUrl: string } | null
      }>
    }
  } | null
}

export type LoadContentItemsQueryVariables = Exact<{
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  orderBy: InputMaybe<Array<ContentItemsOrderBy> | ContentItemsOrderBy>
  filter: InputMaybe<ContentItemFilter>
}>

export type LoadContentItemsQuery = {
  contentItems?: {
    totalCount: number
    pageInfo: {
      startCursor?: string | null
      endCursor?: string | null
      hasNextPage: boolean
      hasPreviousPage: boolean
    }
    nodes: Array<{
      pubDate?: any | null
      title: string
      uid: string
      subtitle?: string | null
      summary?: string | null
      mediaAssets: {
        nodes: Array<{
          duration?: number | null
          fileUid: string
          licenseUid?: string | null
          mediaType: string
          title: string
          uid: string
          file?: {
            contentUrl: string
            contentSize?: number | null
            mimeType?: string | null
          } | null
        }>
      }
      publicationService?: { name: string } | null
    }>
  } | null
}

export type LoadDashboardDataQueryVariables = Exact<{
  start: Scalars['Datetime']
  end: Scalars['Datetime']
}>

export type LoadDashboardDataQuery = {
  repos?: {
    totalCount: number
    nodes: Array<{ did: string; name?: string | null }>
  } | null
  contentItems?: {
    totalCount: number
    nodes: Array<{ pubDate?: any | null }>
  } | null
  mediaAssets?: { totalCount: number } | null
  files?: { totalCount: number } | null
  commits?: { totalCount: number } | null
  concepts?: { totalCount: number } | null
  publicationServices?: {
    totalCount: number
    nodes: Array<{ name: string; contentItems: { totalCount: number } }>
  } | null
  latestConetentItems?: { nodes: Array<{ title: string; uid: string }> } | null
  totalPublicationServices?: { totalCount: number } | null
  totalContentItems?: { totalCount: number } | null
  contentGroupings?: { totalCount: number } | null
  dataSources?: { totalCount: number } | null
  sourceRecords?: { totalCount: number } | null
}

export type LoadRepoStatsQueryVariables = Exact<{
  repoDid: InputMaybe<Scalars['String']>
}>

export type LoadRepoStatsQuery = {
  contentItems?: { totalCount: number } | null
  repos?: { nodes: Array<{ name?: string | null }> } | null
}

export type LoadReposQueryVariables = Exact<{ [key: string]: never }>

export type LoadReposQuery = {
  repos?: { nodes: Array<{ did: string; name?: string | null }> } | null
}
