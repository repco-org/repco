/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: string
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: any
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any
}

export type Actor = {
  /** Reads and enables pagination through a set of `BroadcastService`. */
  broadcastServicesByPublisher: BroadcastServicesConnection
  contactInformation: Scalars['String']
  /** Reads and enables pagination through a set of `Contribution`. */
  contributions: ActorContributionsByActorToContributionAAndBManyToManyConnection
  name: Scalars['String']
  personOrOrganization: Scalars['String']
  /** Reads a single `File` that is related to this `Actor`. */
  profilePicture: Maybe<File>
  profilePictureUid: Scalars['String']
  /** Reads a single `Revision` that is related to this `Actor`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  uid: Scalars['String']
}

export type ActorBroadcastServicesByPublisherArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastServiceCondition>
  filter: InputMaybe<BroadcastServiceFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastServicesOrderBy>>
}

export type ActorContributionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributionCondition>
  filter: InputMaybe<ContributionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributionsOrderBy>>
}

/** A condition to be used against `Actor` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ActorCondition = {
  /** Checks for equality with the object’s `contactInformation` field. */
  contactInformation: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `personOrOrganization` field. */
  personOrOrganization: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `profilePictureUid` field. */
  profilePictureUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A connection to a list of `Contribution` values, with data from `_ActorToContribution`. */
export type ActorContributionsByActorToContributionAAndBManyToManyConnection = {
  /** A list of edges which contains the `Contribution`, info from the `_ActorToContribution`, and the cursor to aid in pagination. */
  edges: Array<ActorContributionsByActorToContributionAAndBManyToManyEdge>
  /** A list of `Contribution` objects. */
  nodes: Array<Contribution>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Contribution` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Contribution` edge in the connection, with data from `_ActorToContribution`. */
export type ActorContributionsByActorToContributionAAndBManyToManyEdge = {
  /** Reads and enables pagination through a set of `_ActorToContribution`. */
  _actorToContributionsByB: _ActorToContributionsConnection
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `Contribution` at the end of the edge. */
  node: Contribution
}

/** A `Contribution` edge in the connection, with data from `_ActorToContribution`. */
export type ActorContributionsByActorToContributionAAndBManyToManyEdge_ActorToContributionsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ActorToContributionCondition>
    filter: InputMaybe<_ActorToContributionFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ActorToContributionsOrderBy>>
  }

/** A filter to be used against `Actor` object types. All fields are combined with a logical ‘and.’ */
export type ActorFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<ActorFilter>>
  /** Filter by the object’s `contactInformation` field. */
  contactInformation: InputMaybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<ActorFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<ActorFilter>>
  /** Filter by the object’s `personOrOrganization` field. */
  personOrOrganization: InputMaybe<StringFilter>
  /** Filter by the object’s `profilePictureUid` field. */
  profilePictureUid: InputMaybe<StringFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `Actor` values. */
export type ActorsConnection = {
  /** A list of edges which contains the `Actor` and cursor to aid in pagination. */
  edges: Array<ActorsEdge>
  /** A list of `Actor` objects. */
  nodes: Array<Actor>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Actor` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Actor` edge in the connection. */
export type ActorsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `Actor` at the end of the edge. */
  node: Actor
}

/** Methods to use when ordering `Actor`. */
export enum ActorsOrderBy {
  ContactInformationAsc = 'CONTACT_INFORMATION_ASC',
  ContactInformationDesc = 'CONTACT_INFORMATION_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PersonOrOrganizationAsc = 'PERSON_OR_ORGANIZATION_ASC',
  PersonOrOrganizationDesc = 'PERSON_OR_ORGANIZATION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProfilePictureUidAsc = 'PROFILE_PICTURE_UID_ASC',
  ProfilePictureUidDesc = 'PROFILE_PICTURE_UID_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type BroadcastEvent = {
  /** Reads a single `BroadcastService` that is related to this `BroadcastEvent`. */
  broadcastService: Maybe<BroadcastService>
  broadcastServiceUid: Scalars['String']
  /** Reads a single `ContentItem` that is related to this `BroadcastEvent`. */
  contentItem: Maybe<ContentItem>
  contentItemUid: Scalars['String']
  duration: Scalars['Float']
  /** Reads a single `Revision` that is related to this `BroadcastEvent`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  start: Scalars['Float']
  uid: Scalars['String']
}

/**
 * A condition to be used against `BroadcastEvent` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type BroadcastEventCondition = {
  /** Checks for equality with the object’s `broadcastServiceUid` field. */
  broadcastServiceUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `contentItemUid` field. */
  contentItemUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `duration` field. */
  duration: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `start` field. */
  start: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A filter to be used against `BroadcastEvent` object types. All fields are combined with a logical ‘and.’ */
export type BroadcastEventFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<BroadcastEventFilter>>
  /** Filter by the object’s `broadcastServiceUid` field. */
  broadcastServiceUid: InputMaybe<StringFilter>
  /** Filter by the object’s `contentItemUid` field. */
  contentItemUid: InputMaybe<StringFilter>
  /** Filter by the object’s `duration` field. */
  duration: InputMaybe<FloatFilter>
  /** Negates the expression. */
  not: InputMaybe<BroadcastEventFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<BroadcastEventFilter>>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `start` field. */
  start: InputMaybe<FloatFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `BroadcastEvent` values. */
export type BroadcastEventsConnection = {
  /** A list of edges which contains the `BroadcastEvent` and cursor to aid in pagination. */
  edges: Array<BroadcastEventsEdge>
  /** A list of `BroadcastEvent` objects. */
  nodes: Array<BroadcastEvent>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `BroadcastEvent` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `BroadcastEvent` edge in the connection. */
export type BroadcastEventsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `BroadcastEvent` at the end of the edge. */
  node: BroadcastEvent
}

/** Methods to use when ordering `BroadcastEvent`. */
export enum BroadcastEventsOrderBy {
  BroadcastServiceUidAsc = 'BROADCAST_SERVICE_UID_ASC',
  BroadcastServiceUidDesc = 'BROADCAST_SERVICE_UID_DESC',
  ContentItemUidAsc = 'CONTENT_ITEM_UID_ASC',
  ContentItemUidDesc = 'CONTENT_ITEM_UID_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type BroadcastService = {
  address: Scalars['String']
  /** Reads and enables pagination through a set of `BroadcastEvent`. */
  broadcastEvents: BroadcastEventsConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItemsByBroadcastEventBroadcastServiceUidAndContentItemUid: BroadcastServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidManyToManyConnection
  medium: Scalars['String']
  name: Scalars['String']
  /** Reads a single `Actor` that is related to this `BroadcastService`. */
  publisher: Maybe<Actor>
  publisherUid: Scalars['String']
  /** Reads a single `Revision` that is related to this `BroadcastService`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  uid: Scalars['String']
}

export type BroadcastServiceBroadcastEventsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastEventCondition>
  filter: InputMaybe<BroadcastEventFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
}

export type BroadcastServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/**
 * A condition to be used against `BroadcastService` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type BroadcastServiceCondition = {
  /** Checks for equality with the object’s `address` field. */
  address: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `medium` field. */
  medium: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `publisherUid` field. */
  publisherUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentItem` values, with data from `BroadcastEvent`. */
export type BroadcastServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `BroadcastEvent`, and the cursor to aid in pagination. */
    edges: Array<BroadcastServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `BroadcastEvent`. */
export type BroadcastServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `BroadcastEvent`. */
    broadcastEvents: BroadcastEventsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `ContentItem` at the end of the edge. */
    node: ContentItem
  }

/** A `ContentItem` edge in the connection, with data from `BroadcastEvent`. */
export type BroadcastServiceContentItemsByBroadcastEventBroadcastServiceUidAndContentItemUidManyToManyEdgeBroadcastEventsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastEventCondition>
    filter: InputMaybe<BroadcastEventFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
  }

/** A filter to be used against `BroadcastService` object types. All fields are combined with a logical ‘and.’ */
export type BroadcastServiceFilter = {
  /** Filter by the object’s `address` field. */
  address: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<BroadcastServiceFilter>>
  /** Filter by the object’s `medium` field. */
  medium: InputMaybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<BroadcastServiceFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<BroadcastServiceFilter>>
  /** Filter by the object’s `publisherUid` field. */
  publisherUid: InputMaybe<StringFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `BroadcastService` values. */
export type BroadcastServicesConnection = {
  /** A list of edges which contains the `BroadcastService` and cursor to aid in pagination. */
  edges: Array<BroadcastServicesEdge>
  /** A list of `BroadcastService` objects. */
  nodes: Array<BroadcastService>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `BroadcastService` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `BroadcastService` edge in the connection. */
export type BroadcastServicesEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `BroadcastService` at the end of the edge. */
  node: BroadcastService
}

/** Methods to use when ordering `BroadcastService`. */
export enum BroadcastServicesOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  MediumAsc = 'MEDIUM_ASC',
  MediumDesc = 'MEDIUM_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PublisherUidAsc = 'PUBLISHER_UID_ASC',
  PublisherUidDesc = 'PUBLISHER_UID_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Chapter = {
  duration: Scalars['Float']
  /** Reads a single `MediaAsset` that is related to this `Chapter`. */
  mediaAsset: Maybe<MediaAsset>
  mediaAssetUid: Scalars['String']
  /** Reads a single `Revision` that is related to this `Chapter`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  start: Scalars['Float']
  title: Scalars['String']
  type: Scalars['String']
  uid: Scalars['String']
}

/** A condition to be used against `Chapter` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ChapterCondition = {
  /** Checks for equality with the object’s `duration` field. */
  duration: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `mediaAssetUid` field. */
  mediaAssetUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `start` field. */
  start: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `title` field. */
  title: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `type` field. */
  type: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Chapter` object types. All fields are combined with a logical ‘and.’ */
export type ChapterFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<ChapterFilter>>
  /** Filter by the object’s `duration` field. */
  duration: InputMaybe<FloatFilter>
  /** Filter by the object’s `mediaAssetUid` field. */
  mediaAssetUid: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<ChapterFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<ChapterFilter>>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `start` field. */
  start: InputMaybe<FloatFilter>
  /** Filter by the object’s `title` field. */
  title: InputMaybe<StringFilter>
  /** Filter by the object’s `type` field. */
  type: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `Chapter` values. */
export type ChaptersConnection = {
  /** A list of edges which contains the `Chapter` and cursor to aid in pagination. */
  edges: Array<ChaptersEdge>
  /** A list of `Chapter` objects. */
  nodes: Array<Chapter>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Chapter` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Chapter` edge in the connection. */
export type ChaptersEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `Chapter` at the end of the edge. */
  node: Chapter
}

/** Methods to use when ordering `Chapter`. */
export enum ChaptersOrderBy {
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  MediaAssetUidAsc = 'MEDIA_ASSET_UID_ASC',
  MediaAssetUidDesc = 'MEDIA_ASSET_UID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Concept = {
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ConceptContentItemsByConceptToContentItemAAndBManyToManyConnection
  description: Scalars['String']
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: ConceptMediaAssetsByConceptToMediaAssetAAndBManyToManyConnection
  name: Scalars['String']
  originNamespace: Scalars['String']
  /** Reads a single `Revision` that is related to this `Concept`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  summary: Scalars['String']
  uid: Scalars['String']
  wikidataId: Scalars['String']
}

export type ConceptContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type ConceptMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

/** A condition to be used against `Concept` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ConceptCondition = {
  /** Checks for equality with the object’s `description` field. */
  description: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `originNamespace` field. */
  originNamespace: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `summary` field. */
  summary: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `wikidataId` field. */
  wikidataId: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentItem` values, with data from `_ConceptToContentItem`. */
export type ConceptContentItemsByConceptToContentItemAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `_ConceptToContentItem`, and the cursor to aid in pagination. */
    edges: Array<ConceptContentItemsByConceptToContentItemAAndBManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `_ConceptToContentItem`. */
export type ConceptContentItemsByConceptToContentItemAAndBManyToManyEdge = {
  /** Reads and enables pagination through a set of `_ConceptToContentItem`. */
  _conceptToContentItemsByB: _ConceptToContentItemsConnection
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `ContentItem` at the end of the edge. */
  node: ContentItem
}

/** A `ContentItem` edge in the connection, with data from `_ConceptToContentItem`. */
export type ConceptContentItemsByConceptToContentItemAAndBManyToManyEdge_ConceptToContentItemsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ConceptToContentItemCondition>
    filter: InputMaybe<_ConceptToContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ConceptToContentItemsOrderBy>>
  }

/** A filter to be used against `Concept` object types. All fields are combined with a logical ‘and.’ */
export type ConceptFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<ConceptFilter>>
  /** Filter by the object’s `description` field. */
  description: InputMaybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<ConceptFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<ConceptFilter>>
  /** Filter by the object’s `originNamespace` field. */
  originNamespace: InputMaybe<StringFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `summary` field. */
  summary: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
  /** Filter by the object’s `wikidataId` field. */
  wikidataId: InputMaybe<StringFilter>
}

/** A connection to a list of `MediaAsset` values, with data from `_ConceptToMediaAsset`. */
export type ConceptMediaAssetsByConceptToMediaAssetAAndBManyToManyConnection = {
  /** A list of edges which contains the `MediaAsset`, info from the `_ConceptToMediaAsset`, and the cursor to aid in pagination. */
  edges: Array<ConceptMediaAssetsByConceptToMediaAssetAAndBManyToManyEdge>
  /** A list of `MediaAsset` objects. */
  nodes: Array<MediaAsset>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `MediaAsset` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `MediaAsset` edge in the connection, with data from `_ConceptToMediaAsset`. */
export type ConceptMediaAssetsByConceptToMediaAssetAAndBManyToManyEdge = {
  /** Reads and enables pagination through a set of `_ConceptToMediaAsset`. */
  _conceptToMediaAssetsByB: _ConceptToMediaAssetsConnection
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `MediaAsset` at the end of the edge. */
  node: MediaAsset
}

/** A `MediaAsset` edge in the connection, with data from `_ConceptToMediaAsset`. */
export type ConceptMediaAssetsByConceptToMediaAssetAAndBManyToManyEdge_ConceptToMediaAssetsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ConceptToMediaAssetCondition>
    filter: InputMaybe<_ConceptToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ConceptToMediaAssetsOrderBy>>
  }

/** A connection to a list of `Concept` values. */
export type ConceptsConnection = {
  /** A list of edges which contains the `Concept` and cursor to aid in pagination. */
  edges: Array<ConceptsEdge>
  /** A list of `Concept` objects. */
  nodes: Array<Concept>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Concept` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Concept` edge in the connection. */
export type ConceptsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `Concept` at the end of the edge. */
  node: Concept
}

/** Methods to use when ordering `Concept`. */
export enum ConceptsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OriginNamespaceAsc = 'ORIGIN_NAMESPACE_ASC',
  OriginNamespaceDesc = 'ORIGIN_NAMESPACE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
  WikidataIdAsc = 'WIKIDATA_ID_ASC',
  WikidataIdDesc = 'WIKIDATA_ID_DESC',
}

export type ContentGrouping = {
  broadcastSchedule: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ContentGroupingContentItemsByContentGroupingToContentItemAAndBManyToManyConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItemsByPrimaryGrouping: ContentItemsConnection
  description: Maybe<Scalars['String']>
  groupingType: Scalars['String']
  /** Reads a single `License` that is related to this `ContentGrouping`. */
  license: Maybe<License>
  licenseUid: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `License`. */
  licensesByContentItemPrimaryGroupingUidAndLicenseUid: ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidManyToManyConnection
  /** Reads a single `Revision` that is related to this `ContentGrouping`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  startingDate: Maybe<Scalars['Datetime']>
  subtitle: Maybe<Scalars['String']>
  summary: Maybe<Scalars['String']>
  terminationDate: Maybe<Scalars['Datetime']>
  title: Scalars['String']
  uid: Scalars['String']
  variant: ContentGroupingVariant
}

export type ContentGroupingContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type ContentGroupingContentItemsByPrimaryGroupingArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<LicenseCondition>
    filter: InputMaybe<LicenseFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<LicensesOrderBy>>
  }

/**
 * A condition to be used against `ContentGrouping` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ContentGroupingCondition = {
  /** Checks for equality with the object’s `broadcastSchedule` field. */
  broadcastSchedule: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `description` field. */
  description: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `groupingType` field. */
  groupingType: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `licenseUid` field. */
  licenseUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `startingDate` field. */
  startingDate: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `subtitle` field. */
  subtitle: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `summary` field. */
  summary: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `terminationDate` field. */
  terminationDate: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `title` field. */
  title: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `variant` field. */
  variant: InputMaybe<ContentGroupingVariant>
}

/** A connection to a list of `ContentItem` values, with data from `_ContentGroupingToContentItem`. */
export type ContentGroupingContentItemsByContentGroupingToContentItemAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `_ContentGroupingToContentItem`, and the cursor to aid in pagination. */
    edges: Array<ContentGroupingContentItemsByContentGroupingToContentItemAAndBManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `_ContentGroupingToContentItem`. */
export type ContentGroupingContentItemsByContentGroupingToContentItemAAndBManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentGroupingToContentItem`. */
    _contentGroupingToContentItemsByB: _ContentGroupingToContentItemsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `ContentItem` at the end of the edge. */
    node: ContentItem
  }

/** A `ContentItem` edge in the connection, with data from `_ContentGroupingToContentItem`. */
export type ContentGroupingContentItemsByContentGroupingToContentItemAAndBManyToManyEdge_ContentGroupingToContentItemsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentGroupingToContentItemCondition>
    filter: InputMaybe<_ContentGroupingToContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentGroupingToContentItemsOrderBy>>
  }

/** A filter to be used against `ContentGrouping` object types. All fields are combined with a logical ‘and.’ */
export type ContentGroupingFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<ContentGroupingFilter>>
  /** Filter by the object’s `broadcastSchedule` field. */
  broadcastSchedule: InputMaybe<StringFilter>
  /** Filter by the object’s `description` field. */
  description: InputMaybe<StringFilter>
  /** Filter by the object’s `groupingType` field. */
  groupingType: InputMaybe<StringFilter>
  /** Filter by the object’s `licenseUid` field. */
  licenseUid: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<ContentGroupingFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<ContentGroupingFilter>>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `startingDate` field. */
  startingDate: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `subtitle` field. */
  subtitle: InputMaybe<StringFilter>
  /** Filter by the object’s `summary` field. */
  summary: InputMaybe<StringFilter>
  /** Filter by the object’s `terminationDate` field. */
  terminationDate: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `title` field. */
  title: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
  /** Filter by the object’s `variant` field. */
  variant: InputMaybe<ContentGroupingVariantFilter>
}

/** A connection to a list of `License` values, with data from `ContentItem`. */
export type ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `ContentItem`. */
export type ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItems: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `ContentItem`. */
export type ContentGroupingLicensesByContentItemPrimaryGroupingUidAndLicenseUidManyToManyEdgeContentItemsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

export enum ContentGroupingVariant {
  Episodic = 'EPISODIC',
  Serial = 'SERIAL',
}

/** A filter to be used against ContentGroupingVariant fields. All fields are combined with a logical ‘and.’ */
export type ContentGroupingVariantFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom: InputMaybe<ContentGroupingVariant>
  /** Equal to the specified value. */
  equalTo: InputMaybe<ContentGroupingVariant>
  /** Greater than the specified value. */
  greaterThan: InputMaybe<ContentGroupingVariant>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo: InputMaybe<ContentGroupingVariant>
  /** Included in the specified list. */
  in: InputMaybe<Array<ContentGroupingVariant>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan: InputMaybe<ContentGroupingVariant>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo: InputMaybe<ContentGroupingVariant>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom: InputMaybe<ContentGroupingVariant>
  /** Not equal to the specified value. */
  notEqualTo: InputMaybe<ContentGroupingVariant>
  /** Not included in the specified list. */
  notIn: InputMaybe<Array<ContentGroupingVariant>>
}

/** A connection to a list of `ContentGrouping` values. */
export type ContentGroupingsConnection = {
  /** A list of edges which contains the `ContentGrouping` and cursor to aid in pagination. */
  edges: Array<ContentGroupingsEdge>
  /** A list of `ContentGrouping` objects. */
  nodes: Array<ContentGrouping>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `ContentGrouping` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `ContentGrouping` edge in the connection. */
export type ContentGroupingsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `ContentGrouping` at the end of the edge. */
  node: ContentGrouping
}

/** Methods to use when ordering `ContentGrouping`. */
export enum ContentGroupingsOrderBy {
  BroadcastScheduleAsc = 'BROADCAST_SCHEDULE_ASC',
  BroadcastScheduleDesc = 'BROADCAST_SCHEDULE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GroupingTypeAsc = 'GROUPING_TYPE_ASC',
  GroupingTypeDesc = 'GROUPING_TYPE_DESC',
  LicenseUidAsc = 'LICENSE_UID_ASC',
  LicenseUidDesc = 'LICENSE_UID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  StartingDateAsc = 'STARTING_DATE_ASC',
  StartingDateDesc = 'STARTING_DATE_DESC',
  SubtitleAsc = 'SUBTITLE_ASC',
  SubtitleDesc = 'SUBTITLE_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TerminationDateAsc = 'TERMINATION_DATE_ASC',
  TerminationDateDesc = 'TERMINATION_DATE_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
  VariantAsc = 'VARIANT_ASC',
  VariantDesc = 'VARIANT_DESC',
}

export type ContentItem = {
  /** Reads and enables pagination through a set of `BroadcastEvent`. */
  broadcastEvents: BroadcastEventsConnection
  /** Reads and enables pagination through a set of `BroadcastService`. */
  broadcastServicesByBroadcastEventContentItemUidAndBroadcastServiceUid: ContentItemBroadcastServicesByBroadcastEventContentItemUidAndBroadcastServiceUidManyToManyConnection
  /** Reads and enables pagination through a set of `Concept`. */
  concepts: ContentItemConceptsByConceptToContentItemBAndAManyToManyConnection
  content: Scalars['String']
  contentFormat: Scalars['String']
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupings: ContentItemContentGroupingsByContentGroupingToContentItemBAndAManyToManyConnection
  /** Reads and enables pagination through a set of `Contribution`. */
  contributions: ContentItemContributionsByContentItemToContributionAAndBManyToManyConnection
  /** Reads a single `License` that is related to this `ContentItem`. */
  license: Maybe<License>
  licenseUid: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: ContentItemMediaAssetsByContentItemToMediaAssetAAndBManyToManyConnection
  /** Reads a single `ContentGrouping` that is related to this `ContentItem`. */
  primaryGrouping: Maybe<ContentGrouping>
  primaryGroupingUid: Maybe<Scalars['String']>
  pubDate: Maybe<Scalars['Datetime']>
  /** Reads a single `Revision` that is related to this `ContentItem`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  subtitle: Maybe<Scalars['String']>
  summary: Maybe<Scalars['String']>
  title: Scalars['String']
  uid: Scalars['String']
}

export type ContentItemBroadcastEventsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastEventCondition>
  filter: InputMaybe<BroadcastEventFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
}

export type ContentItemBroadcastServicesByBroadcastEventContentItemUidAndBroadcastServiceUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastServiceCondition>
    filter: InputMaybe<BroadcastServiceFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastServicesOrderBy>>
  }

export type ContentItemConceptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type ContentItemContentGroupingsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentGroupingCondition>
  filter: InputMaybe<ContentGroupingFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
}

export type ContentItemContributionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributionCondition>
  filter: InputMaybe<ContributionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributionsOrderBy>>
}

export type ContentItemMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

/** A connection to a list of `BroadcastService` values, with data from `BroadcastEvent`. */
export type ContentItemBroadcastServicesByBroadcastEventContentItemUidAndBroadcastServiceUidManyToManyConnection =
  {
    /** A list of edges which contains the `BroadcastService`, info from the `BroadcastEvent`, and the cursor to aid in pagination. */
    edges: Array<ContentItemBroadcastServicesByBroadcastEventContentItemUidAndBroadcastServiceUidManyToManyEdge>
    /** A list of `BroadcastService` objects. */
    nodes: Array<BroadcastService>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `BroadcastService` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `BroadcastService` edge in the connection, with data from `BroadcastEvent`. */
export type ContentItemBroadcastServicesByBroadcastEventContentItemUidAndBroadcastServiceUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `BroadcastEvent`. */
    broadcastEvents: BroadcastEventsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `BroadcastService` at the end of the edge. */
    node: BroadcastService
  }

/** A `BroadcastService` edge in the connection, with data from `BroadcastEvent`. */
export type ContentItemBroadcastServicesByBroadcastEventContentItemUidAndBroadcastServiceUidManyToManyEdgeBroadcastEventsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastEventCondition>
    filter: InputMaybe<BroadcastEventFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
  }

/** A connection to a list of `Concept` values, with data from `_ConceptToContentItem`. */
export type ContentItemConceptsByConceptToContentItemBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `Concept`, info from the `_ConceptToContentItem`, and the cursor to aid in pagination. */
    edges: Array<ContentItemConceptsByConceptToContentItemBAndAManyToManyEdge>
    /** A list of `Concept` objects. */
    nodes: Array<Concept>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Concept` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Concept` edge in the connection, with data from `_ConceptToContentItem`. */
export type ContentItemConceptsByConceptToContentItemBAndAManyToManyEdge = {
  /** Reads and enables pagination through a set of `_ConceptToContentItem`. */
  _conceptToContentItemsByA: _ConceptToContentItemsConnection
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `Concept` at the end of the edge. */
  node: Concept
}

/** A `Concept` edge in the connection, with data from `_ConceptToContentItem`. */
export type ContentItemConceptsByConceptToContentItemBAndAManyToManyEdge_ConceptToContentItemsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ConceptToContentItemCondition>
    filter: InputMaybe<_ConceptToContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ConceptToContentItemsOrderBy>>
  }

/**
 * A condition to be used against `ContentItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ContentItemCondition = {
  /** Checks for equality with the object’s `content` field. */
  content: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `contentFormat` field. */
  contentFormat: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `licenseUid` field. */
  licenseUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `primaryGroupingUid` field. */
  primaryGroupingUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `pubDate` field. */
  pubDate: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `subtitle` field. */
  subtitle: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `summary` field. */
  summary: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `title` field. */
  title: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentGrouping` values, with data from `_ContentGroupingToContentItem`. */
export type ContentItemContentGroupingsByContentGroupingToContentItemBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `ContentGrouping`, info from the `_ContentGroupingToContentItem`, and the cursor to aid in pagination. */
    edges: Array<ContentItemContentGroupingsByContentGroupingToContentItemBAndAManyToManyEdge>
    /** A list of `ContentGrouping` objects. */
    nodes: Array<ContentGrouping>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentGrouping` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentGrouping` edge in the connection, with data from `_ContentGroupingToContentItem`. */
export type ContentItemContentGroupingsByContentGroupingToContentItemBAndAManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentGroupingToContentItem`. */
    _contentGroupingToContentItemsByA: _ContentGroupingToContentItemsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `ContentGrouping` at the end of the edge. */
    node: ContentGrouping
  }

/** A `ContentGrouping` edge in the connection, with data from `_ContentGroupingToContentItem`. */
export type ContentItemContentGroupingsByContentGroupingToContentItemBAndAManyToManyEdge_ContentGroupingToContentItemsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentGroupingToContentItemCondition>
    filter: InputMaybe<_ContentGroupingToContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentGroupingToContentItemsOrderBy>>
  }

/** A connection to a list of `Contribution` values, with data from `_ContentItemToContribution`. */
export type ContentItemContributionsByContentItemToContributionAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `Contribution`, info from the `_ContentItemToContribution`, and the cursor to aid in pagination. */
    edges: Array<ContentItemContributionsByContentItemToContributionAAndBManyToManyEdge>
    /** A list of `Contribution` objects. */
    nodes: Array<Contribution>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Contribution` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Contribution` edge in the connection, with data from `_ContentItemToContribution`. */
export type ContentItemContributionsByContentItemToContributionAAndBManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentItemToContribution`. */
    _contentItemToContributionsByB: _ContentItemToContributionsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `Contribution` at the end of the edge. */
    node: Contribution
  }

/** A `Contribution` edge in the connection, with data from `_ContentItemToContribution`. */
export type ContentItemContributionsByContentItemToContributionAAndBManyToManyEdge_ContentItemToContributionsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentItemToContributionCondition>
    filter: InputMaybe<_ContentItemToContributionFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentItemToContributionsOrderBy>>
  }

/** A filter to be used against `ContentItem` object types. All fields are combined with a logical ‘and.’ */
export type ContentItemFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<ContentItemFilter>>
  /** Filter by the object’s `content` field. */
  content: InputMaybe<StringFilter>
  /** Filter by the object’s `contentFormat` field. */
  contentFormat: InputMaybe<StringFilter>
  /** Filter by the object’s `licenseUid` field. */
  licenseUid: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<ContentItemFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<ContentItemFilter>>
  /** Filter by the object’s `primaryGroupingUid` field. */
  primaryGroupingUid: InputMaybe<StringFilter>
  /** Filter by the object’s `pubDate` field. */
  pubDate: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `subtitle` field. */
  subtitle: InputMaybe<StringFilter>
  /** Filter by the object’s `summary` field. */
  summary: InputMaybe<StringFilter>
  /** Filter by the object’s `title` field. */
  title: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `MediaAsset` values, with data from `_ContentItemToMediaAsset`. */
export type ContentItemMediaAssetsByContentItemToMediaAssetAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `MediaAsset`, info from the `_ContentItemToMediaAsset`, and the cursor to aid in pagination. */
    edges: Array<ContentItemMediaAssetsByContentItemToMediaAssetAAndBManyToManyEdge>
    /** A list of `MediaAsset` objects. */
    nodes: Array<MediaAsset>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `MediaAsset` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `MediaAsset` edge in the connection, with data from `_ContentItemToMediaAsset`. */
export type ContentItemMediaAssetsByContentItemToMediaAssetAAndBManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentItemToMediaAsset`. */
    _contentItemToMediaAssetsByB: _ContentItemToMediaAssetsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `MediaAsset` at the end of the edge. */
    node: MediaAsset
  }

/** A `MediaAsset` edge in the connection, with data from `_ContentItemToMediaAsset`. */
export type ContentItemMediaAssetsByContentItemToMediaAssetAAndBManyToManyEdge_ContentItemToMediaAssetsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentItemToMediaAssetCondition>
    filter: InputMaybe<_ContentItemToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentItemToMediaAssetsOrderBy>>
  }

/** A connection to a list of `ContentItem` values. */
export type ContentItemsConnection = {
  /** A list of edges which contains the `ContentItem` and cursor to aid in pagination. */
  edges: Array<ContentItemsEdge>
  /** A list of `ContentItem` objects. */
  nodes: Array<ContentItem>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `ContentItem` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `ContentItem` edge in the connection. */
export type ContentItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `ContentItem` at the end of the edge. */
  node: ContentItem
}

/** Methods to use when ordering `ContentItem`. */
export enum ContentItemsOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  ContentFormatAsc = 'CONTENT_FORMAT_ASC',
  ContentFormatDesc = 'CONTENT_FORMAT_DESC',
  LicenseUidAsc = 'LICENSE_UID_ASC',
  LicenseUidDesc = 'LICENSE_UID_DESC',
  Natural = 'NATURAL',
  PrimaryGroupingUidAsc = 'PRIMARY_GROUPING_UID_ASC',
  PrimaryGroupingUidDesc = 'PRIMARY_GROUPING_UID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PubDateAsc = 'PUB_DATE_ASC',
  PubDateDesc = 'PUB_DATE_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  SubtitleAsc = 'SUBTITLE_ASC',
  SubtitleDesc = 'SUBTITLE_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type Contribution = {
  /** Reads and enables pagination through a set of `Actor`. */
  actors: ContributionActorsByActorToContributionBAndAManyToManyConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ContributionContentItemsByContentItemToContributionBAndAManyToManyConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: ContributionMediaAssetsByContributionToMediaAssetAAndBManyToManyConnection
  /** Reads a single `Revision` that is related to this `Contribution`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  role: Scalars['String']
  uid: Scalars['String']
}

export type ContributionActorsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ActorCondition>
  filter: InputMaybe<ActorFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ActorsOrderBy>>
}

export type ContributionContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type ContributionMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

/** A connection to a list of `Actor` values, with data from `_ActorToContribution`. */
export type ContributionActorsByActorToContributionBAndAManyToManyConnection = {
  /** A list of edges which contains the `Actor`, info from the `_ActorToContribution`, and the cursor to aid in pagination. */
  edges: Array<ContributionActorsByActorToContributionBAndAManyToManyEdge>
  /** A list of `Actor` objects. */
  nodes: Array<Actor>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Actor` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Actor` edge in the connection, with data from `_ActorToContribution`. */
export type ContributionActorsByActorToContributionBAndAManyToManyEdge = {
  /** Reads and enables pagination through a set of `_ActorToContribution`. */
  _actorToContributionsByA: _ActorToContributionsConnection
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `Actor` at the end of the edge. */
  node: Actor
}

/** A `Actor` edge in the connection, with data from `_ActorToContribution`. */
export type ContributionActorsByActorToContributionBAndAManyToManyEdge_ActorToContributionsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ActorToContributionCondition>
    filter: InputMaybe<_ActorToContributionFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ActorToContributionsOrderBy>>
  }

/**
 * A condition to be used against `Contribution` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ContributionCondition = {
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `role` field. */
  role: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentItem` values, with data from `_ContentItemToContribution`. */
export type ContributionContentItemsByContentItemToContributionBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `_ContentItemToContribution`, and the cursor to aid in pagination. */
    edges: Array<ContributionContentItemsByContentItemToContributionBAndAManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `_ContentItemToContribution`. */
export type ContributionContentItemsByContentItemToContributionBAndAManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentItemToContribution`. */
    _contentItemToContributionsByA: _ContentItemToContributionsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `ContentItem` at the end of the edge. */
    node: ContentItem
  }

/** A `ContentItem` edge in the connection, with data from `_ContentItemToContribution`. */
export type ContributionContentItemsByContentItemToContributionBAndAManyToManyEdge_ContentItemToContributionsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentItemToContributionCondition>
    filter: InputMaybe<_ContentItemToContributionFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentItemToContributionsOrderBy>>
  }

/** A filter to be used against `Contribution` object types. All fields are combined with a logical ‘and.’ */
export type ContributionFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<ContributionFilter>>
  /** Negates the expression. */
  not: InputMaybe<ContributionFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<ContributionFilter>>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `role` field. */
  role: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `MediaAsset` values, with data from `_ContributionToMediaAsset`. */
export type ContributionMediaAssetsByContributionToMediaAssetAAndBManyToManyConnection =
  {
    /** A list of edges which contains the `MediaAsset`, info from the `_ContributionToMediaAsset`, and the cursor to aid in pagination. */
    edges: Array<ContributionMediaAssetsByContributionToMediaAssetAAndBManyToManyEdge>
    /** A list of `MediaAsset` objects. */
    nodes: Array<MediaAsset>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `MediaAsset` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `MediaAsset` edge in the connection, with data from `_ContributionToMediaAsset`. */
export type ContributionMediaAssetsByContributionToMediaAssetAAndBManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContributionToMediaAsset`. */
    _contributionToMediaAssetsByB: _ContributionToMediaAssetsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `MediaAsset` at the end of the edge. */
    node: MediaAsset
  }

/** A `MediaAsset` edge in the connection, with data from `_ContributionToMediaAsset`. */
export type ContributionMediaAssetsByContributionToMediaAssetAAndBManyToManyEdge_ContributionToMediaAssetsByBArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContributionToMediaAssetCondition>
    filter: InputMaybe<_ContributionToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContributionToMediaAssetsOrderBy>>
  }

/** A connection to a list of `Contribution` values. */
export type ContributionsConnection = {
  /** A list of edges which contains the `Contribution` and cursor to aid in pagination. */
  edges: Array<ContributionsEdge>
  /** A list of `Contribution` objects. */
  nodes: Array<Contribution>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Contribution` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Contribution` edge in the connection. */
export type ContributionsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `Contribution` at the end of the edge. */
  node: Contribution
}

/** Methods to use when ordering `Contribution`. */
export enum ContributionsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  RoleAsc = 'ROLE_ASC',
  RoleDesc = 'ROLE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type DataSource = {
  config: Maybe<Scalars['JSON']>
  cursor: Scalars['String']
  pluginUid: Maybe<Scalars['String']>
  uid: Scalars['String']
}

/**
 * A condition to be used against `DataSource` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DataSourceCondition = {
  /** Checks for equality with the object’s `config` field. */
  config: InputMaybe<Scalars['JSON']>
  /** Checks for equality with the object’s `cursor` field. */
  cursor: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `pluginUid` field. */
  pluginUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A filter to be used against `DataSource` object types. All fields are combined with a logical ‘and.’ */
export type DataSourceFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<DataSourceFilter>>
  /** Filter by the object’s `config` field. */
  config: InputMaybe<JsonFilter>
  /** Filter by the object’s `cursor` field. */
  cursor: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<DataSourceFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<DataSourceFilter>>
  /** Filter by the object’s `pluginUid` field. */
  pluginUid: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `DataSource` values. */
export type DataSourcesConnection = {
  /** A list of edges which contains the `DataSource` and cursor to aid in pagination. */
  edges: Array<DataSourcesEdge>
  /** A list of `DataSource` objects. */
  nodes: Array<DataSource>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `DataSource` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `DataSource` edge in the connection. */
export type DataSourcesEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `DataSource` at the end of the edge. */
  node: DataSource
}

/** Methods to use when ordering `DataSource`. */
export enum DataSourcesOrderBy {
  ConfigAsc = 'CONFIG_ASC',
  ConfigDesc = 'CONFIG_DESC',
  CursorAsc = 'CURSOR_ASC',
  CursorDesc = 'CURSOR_DESC',
  Natural = 'NATURAL',
  PluginUidAsc = 'PLUGIN_UID_ASC',
  PluginUidDesc = 'PLUGIN_UID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom: InputMaybe<Scalars['Datetime']>
  /** Equal to the specified value. */
  equalTo: InputMaybe<Scalars['Datetime']>
  /** Greater than the specified value. */
  greaterThan: InputMaybe<Scalars['Datetime']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo: InputMaybe<Scalars['Datetime']>
  /** Included in the specified list. */
  in: InputMaybe<Array<Scalars['Datetime']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan: InputMaybe<Scalars['Datetime']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo: InputMaybe<Scalars['Datetime']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom: InputMaybe<Scalars['Datetime']>
  /** Not equal to the specified value. */
  notEqualTo: InputMaybe<Scalars['Datetime']>
  /** Not included in the specified list. */
  notIn: InputMaybe<Array<Scalars['Datetime']>>
}

export type File = {
  /** Reads and enables pagination through a set of `Actor`. */
  actorsByProfilePicture: ActorsConnection
  additionalMetadata: Maybe<Scalars['String']>
  bitrate: Maybe<Scalars['Int']>
  codec: Maybe<Scalars['String']>
  contentUrl: Scalars['String']
  duration: Maybe<Scalars['Float']>
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetFileUidAndTeaserImageUid: FileFilesByMediaAssetFileUidAndTeaserImageUidManyToManyConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetTeaserImageUidAndFileUid: FileFilesByMediaAssetTeaserImageUidAndFileUidManyToManyConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByMediaAssetFileUidAndLicenseUid: FileLicensesByMediaAssetFileUidAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByMediaAssetTeaserImageUidAndLicenseUid: FileLicensesByMediaAssetTeaserImageUidAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssetsByTeaserImage: MediaAssetsConnection
  mimeType: Maybe<Scalars['String']>
  multihash: Maybe<Scalars['String']>
  resolution: Maybe<Scalars['String']>
  /** Reads a single `Revision` that is related to this `File`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  uid: Scalars['String']
}

export type FileActorsByProfilePictureArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ActorCondition>
  filter: InputMaybe<ActorFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ActorsOrderBy>>
}

export type FileFilesByMediaAssetFileUidAndTeaserImageUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type FileFilesByMediaAssetTeaserImageUidAndFileUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type FileLicensesByMediaAssetFileUidAndLicenseUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type FileLicensesByMediaAssetTeaserImageUidAndLicenseUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type FileMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

export type FileMediaAssetsByTeaserImageArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

/** A condition to be used against `File` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FileCondition = {
  /** Checks for equality with the object’s `additionalMetadata` field. */
  additionalMetadata: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `bitrate` field. */
  bitrate: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `codec` field. */
  codec: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `contentUrl` field. */
  contentUrl: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `duration` field. */
  duration: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `mimeType` field. */
  mimeType: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `multihash` field. */
  multihash: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `resolution` field. */
  resolution: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type FileFilesByMediaAssetFileUidAndTeaserImageUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<FileFilesByMediaAssetFileUidAndTeaserImageUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type FileFilesByMediaAssetFileUidAndTeaserImageUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssetsByTeaserImage: MediaAssetsConnection
  /** The `File` at the end of the edge. */
  node: File
}

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type FileFilesByMediaAssetFileUidAndTeaserImageUidManyToManyEdgeMediaAssetsByTeaserImageArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type FileFilesByMediaAssetTeaserImageUidAndFileUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<FileFilesByMediaAssetTeaserImageUidAndFileUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type FileFilesByMediaAssetTeaserImageUidAndFileUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** The `File` at the end of the edge. */
  node: File
}

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type FileFilesByMediaAssetTeaserImageUidAndFileUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A filter to be used against `File` object types. All fields are combined with a logical ‘and.’ */
export type FileFilter = {
  /** Filter by the object’s `additionalMetadata` field. */
  additionalMetadata: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<FileFilter>>
  /** Filter by the object’s `bitrate` field. */
  bitrate: InputMaybe<IntFilter>
  /** Filter by the object’s `codec` field. */
  codec: InputMaybe<StringFilter>
  /** Filter by the object’s `contentUrl` field. */
  contentUrl: InputMaybe<StringFilter>
  /** Filter by the object’s `duration` field. */
  duration: InputMaybe<FloatFilter>
  /** Filter by the object’s `mimeType` field. */
  mimeType: InputMaybe<StringFilter>
  /** Filter by the object’s `multihash` field. */
  multihash: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<FileFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<FileFilter>>
  /** Filter by the object’s `resolution` field. */
  resolution: InputMaybe<StringFilter>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `License` values, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetFileUidAndLicenseUidManyToManyConnection = {
  /** A list of edges which contains the `License`, info from the `MediaAsset`, and the cursor to aid in pagination. */
  edges: Array<FileLicensesByMediaAssetFileUidAndLicenseUidManyToManyEdge>
  /** A list of `License` objects. */
  nodes: Array<License>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `License` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetFileUidAndLicenseUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** The `License` at the end of the edge. */
  node: License
}

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetFileUidAndLicenseUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `License` values, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetTeaserImageUidAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<FileLicensesByMediaAssetTeaserImageUidAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetTeaserImageUidAndLicenseUidManyToManyEdge =
  {
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** Reads and enables pagination through a set of `MediaAsset`. */
    mediaAssets: MediaAssetsConnection
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type FileLicensesByMediaAssetTeaserImageUidAndLicenseUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `File` values. */
export type FilesConnection = {
  /** A list of edges which contains the `File` and cursor to aid in pagination. */
  edges: Array<FilesEdge>
  /** A list of `File` objects. */
  nodes: Array<File>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `File` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `File` edge in the connection. */
export type FilesEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `File` at the end of the edge. */
  node: File
}

/** Methods to use when ordering `File`. */
export enum FilesOrderBy {
  AdditionalMetadataAsc = 'ADDITIONAL_METADATA_ASC',
  AdditionalMetadataDesc = 'ADDITIONAL_METADATA_DESC',
  BitrateAsc = 'BITRATE_ASC',
  BitrateDesc = 'BITRATE_DESC',
  CodecAsc = 'CODEC_ASC',
  CodecDesc = 'CODEC_DESC',
  ContentUrlAsc = 'CONTENT_URL_ASC',
  ContentUrlDesc = 'CONTENT_URL_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  MimeTypeAsc = 'MIME_TYPE_ASC',
  MimeTypeDesc = 'MIME_TYPE_DESC',
  MultihashAsc = 'MULTIHASH_ASC',
  MultihashDesc = 'MULTIHASH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ResolutionAsc = 'RESOLUTION_ASC',
  ResolutionDesc = 'RESOLUTION_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom: InputMaybe<Scalars['Float']>
  /** Equal to the specified value. */
  equalTo: InputMaybe<Scalars['Float']>
  /** Greater than the specified value. */
  greaterThan: InputMaybe<Scalars['Float']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo: InputMaybe<Scalars['Float']>
  /** Included in the specified list. */
  in: InputMaybe<Array<Scalars['Float']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan: InputMaybe<Scalars['Float']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo: InputMaybe<Scalars['Float']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom: InputMaybe<Scalars['Float']>
  /** Not equal to the specified value. */
  notEqualTo: InputMaybe<Scalars['Float']>
  /** Not included in the specified list. */
  notIn: InputMaybe<Array<Scalars['Float']>>
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom: InputMaybe<Scalars['Int']>
  /** Equal to the specified value. */
  equalTo: InputMaybe<Scalars['Int']>
  /** Greater than the specified value. */
  greaterThan: InputMaybe<Scalars['Int']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo: InputMaybe<Scalars['Int']>
  /** Included in the specified list. */
  in: InputMaybe<Array<Scalars['Int']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan: InputMaybe<Scalars['Int']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo: InputMaybe<Scalars['Int']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom: InputMaybe<Scalars['Int']>
  /** Not equal to the specified value. */
  notEqualTo: InputMaybe<Scalars['Int']>
  /** Not included in the specified list. */
  notIn: InputMaybe<Array<Scalars['Int']>>
}

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy: InputMaybe<Scalars['JSON']>
  /** Contains the specified JSON. */
  contains: InputMaybe<Scalars['JSON']>
  /** Contains all of the specified keys. */
  containsAllKeys: InputMaybe<Array<Scalars['String']>>
  /** Contains any of the specified keys. */
  containsAnyKeys: InputMaybe<Array<Scalars['String']>>
  /** Contains the specified key. */
  containsKey: InputMaybe<Scalars['String']>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom: InputMaybe<Scalars['JSON']>
  /** Equal to the specified value. */
  equalTo: InputMaybe<Scalars['JSON']>
  /** Greater than the specified value. */
  greaterThan: InputMaybe<Scalars['JSON']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo: InputMaybe<Scalars['JSON']>
  /** Included in the specified list. */
  in: InputMaybe<Array<Scalars['JSON']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan: InputMaybe<Scalars['JSON']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo: InputMaybe<Scalars['JSON']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom: InputMaybe<Scalars['JSON']>
  /** Not equal to the specified value. */
  notEqualTo: InputMaybe<Scalars['JSON']>
  /** Not included in the specified list. */
  notIn: InputMaybe<Array<Scalars['JSON']>>
}

export type License = {
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupings: ContentGroupingsConnection
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupingsByContentItemLicenseUidAndPrimaryGroupingUid: LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidManyToManyConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ContentItemsConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetLicenseUidAndFileUid: LicenseFilesByMediaAssetLicenseUidAndFileUidManyToManyConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetLicenseUidAndTeaserImageUid: LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidManyToManyConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  name: Scalars['String']
  /** Reads a single `Revision` that is related to this `License`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  uid: Scalars['String']
}

export type LicenseContentGroupingsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentGroupingCondition>
  filter: InputMaybe<ContentGroupingFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
}

export type LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentGroupingCondition>
    filter: InputMaybe<ContentGroupingFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
  }

export type LicenseContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type LicenseFilesByMediaAssetLicenseUidAndFileUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type LicenseMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

/** A condition to be used against `License` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LicenseCondition = {
  /** Checks for equality with the object’s `name` field. */
  name: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentGrouping` values, with data from `ContentItem`. */
export type LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidManyToManyConnection =
  {
    /** A list of edges which contains the `ContentGrouping`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidManyToManyEdge>
    /** A list of `ContentGrouping` objects. */
    nodes: Array<ContentGrouping>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentGrouping` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentGrouping` edge in the connection, with data from `ContentItem`. */
export type LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItemsByPrimaryGrouping: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `ContentGrouping` at the end of the edge. */
    node: ContentGrouping
  }

/** A `ContentGrouping` edge in the connection, with data from `ContentItem`. */
export type LicenseContentGroupingsByContentItemLicenseUidAndPrimaryGroupingUidManyToManyEdgeContentItemsByPrimaryGroupingArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndFileUidManyToManyConnection = {
  /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
  edges: Array<LicenseFilesByMediaAssetLicenseUidAndFileUidManyToManyEdge>
  /** A list of `File` objects. */
  nodes: Array<File>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `File` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndFileUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** The `File` at the end of the edge. */
  node: File
}

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndFileUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidManyToManyEdge =
  {
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** Reads and enables pagination through a set of `MediaAsset`. */
    mediaAssetsByTeaserImage: MediaAssetsConnection
    /** The `File` at the end of the edge. */
    node: File
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type LicenseFilesByMediaAssetLicenseUidAndTeaserImageUidManyToManyEdgeMediaAssetsByTeaserImageArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A filter to be used against `License` object types. All fields are combined with a logical ‘and.’ */
export type LicenseFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<LicenseFilter>>
  /** Filter by the object’s `name` field. */
  name: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<LicenseFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<LicenseFilter>>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `License` values. */
export type LicensesConnection = {
  /** A list of edges which contains the `License` and cursor to aid in pagination. */
  edges: Array<LicensesEdge>
  /** A list of `License` objects. */
  nodes: Array<License>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `License` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `License` edge in the connection. */
export type LicensesEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `License` at the end of the edge. */
  node: License
}

/** Methods to use when ordering `License`. */
export enum LicensesOrderBy {
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type MediaAsset = {
  /** Reads and enables pagination through a set of `Chapter`. */
  chapters: ChaptersConnection
  /** Reads and enables pagination through a set of `Concept`. */
  concepts: MediaAssetConceptsByConceptToMediaAssetBAndAManyToManyConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: MediaAssetContentItemsByContentItemToMediaAssetBAndAManyToManyConnection
  /** Reads and enables pagination through a set of `Contribution`. */
  contributions: MediaAssetContributionsByContributionToMediaAssetBAndAManyToManyConnection
  description: Maybe<Scalars['String']>
  duration: Maybe<Scalars['Float']>
  /** Reads a single `File` that is related to this `MediaAsset`. */
  file: Maybe<File>
  fileUid: Scalars['String']
  /** Reads a single `License` that is related to this `MediaAsset`. */
  license: Maybe<License>
  licenseUid: Maybe<Scalars['String']>
  mediaType: Scalars['String']
  /** Reads a single `Revision` that is related to this `MediaAsset`. */
  revision: Maybe<Revision>
  revisionId: Scalars['String']
  /** Reads a single `File` that is related to this `MediaAsset`. */
  teaserImage: Maybe<File>
  teaserImageUid: Maybe<Scalars['String']>
  title: Scalars['String']
  /** Reads and enables pagination through a set of `Transcript`. */
  transcripts: TranscriptsConnection
  uid: Scalars['String']
}

export type MediaAssetChaptersArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ChapterCondition>
  filter: InputMaybe<ChapterFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ChaptersOrderBy>>
}

export type MediaAssetConceptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type MediaAssetContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type MediaAssetContributionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributionCondition>
  filter: InputMaybe<ContributionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributionsOrderBy>>
}

export type MediaAssetTranscriptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<TranscriptCondition>
  filter: InputMaybe<TranscriptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<TranscriptsOrderBy>>
}

/** A connection to a list of `Concept` values, with data from `_ConceptToMediaAsset`. */
export type MediaAssetConceptsByConceptToMediaAssetBAndAManyToManyConnection = {
  /** A list of edges which contains the `Concept`, info from the `_ConceptToMediaAsset`, and the cursor to aid in pagination. */
  edges: Array<MediaAssetConceptsByConceptToMediaAssetBAndAManyToManyEdge>
  /** A list of `Concept` objects. */
  nodes: Array<Concept>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Concept` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Concept` edge in the connection, with data from `_ConceptToMediaAsset`. */
export type MediaAssetConceptsByConceptToMediaAssetBAndAManyToManyEdge = {
  /** Reads and enables pagination through a set of `_ConceptToMediaAsset`. */
  _conceptToMediaAssetsByA: _ConceptToMediaAssetsConnection
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `Concept` at the end of the edge. */
  node: Concept
}

/** A `Concept` edge in the connection, with data from `_ConceptToMediaAsset`. */
export type MediaAssetConceptsByConceptToMediaAssetBAndAManyToManyEdge_ConceptToMediaAssetsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ConceptToMediaAssetCondition>
    filter: InputMaybe<_ConceptToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ConceptToMediaAssetsOrderBy>>
  }

/**
 * A condition to be used against `MediaAsset` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MediaAssetCondition = {
  /** Checks for equality with the object’s `description` field. */
  description: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `duration` field. */
  duration: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `fileUid` field. */
  fileUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `licenseUid` field. */
  licenseUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `mediaType` field. */
  mediaType: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `teaserImageUid` field. */
  teaserImageUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `title` field. */
  title: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentItem` values, with data from `_ContentItemToMediaAsset`. */
export type MediaAssetContentItemsByContentItemToMediaAssetBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `_ContentItemToMediaAsset`, and the cursor to aid in pagination. */
    edges: Array<MediaAssetContentItemsByContentItemToMediaAssetBAndAManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `_ContentItemToMediaAsset`. */
export type MediaAssetContentItemsByContentItemToMediaAssetBAndAManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContentItemToMediaAsset`. */
    _contentItemToMediaAssetsByA: _ContentItemToMediaAssetsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `ContentItem` at the end of the edge. */
    node: ContentItem
  }

/** A `ContentItem` edge in the connection, with data from `_ContentItemToMediaAsset`. */
export type MediaAssetContentItemsByContentItemToMediaAssetBAndAManyToManyEdge_ContentItemToMediaAssetsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContentItemToMediaAssetCondition>
    filter: InputMaybe<_ContentItemToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContentItemToMediaAssetsOrderBy>>
  }

/** A connection to a list of `Contribution` values, with data from `_ContributionToMediaAsset`. */
export type MediaAssetContributionsByContributionToMediaAssetBAndAManyToManyConnection =
  {
    /** A list of edges which contains the `Contribution`, info from the `_ContributionToMediaAsset`, and the cursor to aid in pagination. */
    edges: Array<MediaAssetContributionsByContributionToMediaAssetBAndAManyToManyEdge>
    /** A list of `Contribution` objects. */
    nodes: Array<Contribution>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Contribution` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Contribution` edge in the connection, with data from `_ContributionToMediaAsset`. */
export type MediaAssetContributionsByContributionToMediaAssetBAndAManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `_ContributionToMediaAsset`. */
    _contributionToMediaAssetsByA: _ContributionToMediaAssetsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `Contribution` at the end of the edge. */
    node: Contribution
  }

/** A `Contribution` edge in the connection, with data from `_ContributionToMediaAsset`. */
export type MediaAssetContributionsByContributionToMediaAssetBAndAManyToManyEdge_ContributionToMediaAssetsByAArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<_ContributionToMediaAssetCondition>
    filter: InputMaybe<_ContributionToMediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<_ContributionToMediaAssetsOrderBy>>
  }

/** A filter to be used against `MediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type MediaAssetFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<MediaAssetFilter>>
  /** Filter by the object’s `description` field. */
  description: InputMaybe<StringFilter>
  /** Filter by the object’s `duration` field. */
  duration: InputMaybe<FloatFilter>
  /** Filter by the object’s `fileUid` field. */
  fileUid: InputMaybe<StringFilter>
  /** Filter by the object’s `licenseUid` field. */
  licenseUid: InputMaybe<StringFilter>
  /** Filter by the object’s `mediaType` field. */
  mediaType: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<MediaAssetFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<MediaAssetFilter>>
  /** Filter by the object’s `revisionId` field. */
  revisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `teaserImageUid` field. */
  teaserImageUid: InputMaybe<StringFilter>
  /** Filter by the object’s `title` field. */
  title: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `MediaAsset` values. */
export type MediaAssetsConnection = {
  /** A list of edges which contains the `MediaAsset` and cursor to aid in pagination. */
  edges: Array<MediaAssetsEdge>
  /** A list of `MediaAsset` objects. */
  nodes: Array<MediaAsset>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `MediaAsset` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `MediaAsset` edge in the connection. */
export type MediaAssetsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `MediaAsset` at the end of the edge. */
  node: MediaAsset
}

/** Methods to use when ordering `MediaAsset`. */
export enum MediaAssetsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  FileUidAsc = 'FILE_UID_ASC',
  FileUidDesc = 'FILE_UID_DESC',
  LicenseUidAsc = 'LICENSE_UID_ASC',
  LicenseUidDesc = 'LICENSE_UID_DESC',
  MediaTypeAsc = 'MEDIA_TYPE_ASC',
  MediaTypeDesc = 'MEDIA_TYPE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevisionIdAsc = 'REVISION_ID_ASC',
  RevisionIdDesc = 'REVISION_ID_DESC',
  TeaserImageUidAsc = 'TEASER_IMAGE_UID_ASC',
  TeaserImageUidDesc = 'TEASER_IMAGE_UID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

/** Information about pagination in a connection. */
export type PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']>
}

/** The root query type which gives access points into the data universe. */
export type Query = {
  actor: Maybe<Actor>
  /** Reads and enables pagination through a set of `Actor`. */
  actors: Maybe<ActorsConnection>
  broadcastEvent: Maybe<BroadcastEvent>
  /** Reads and enables pagination through a set of `BroadcastEvent`. */
  broadcastEvents: Maybe<BroadcastEventsConnection>
  broadcastService: Maybe<BroadcastService>
  /** Reads and enables pagination through a set of `BroadcastService`. */
  broadcastServices: Maybe<BroadcastServicesConnection>
  chapter: Maybe<Chapter>
  /** Reads and enables pagination through a set of `Chapter`. */
  chapters: Maybe<ChaptersConnection>
  concept: Maybe<Concept>
  /** Reads and enables pagination through a set of `Concept`. */
  concepts: Maybe<ConceptsConnection>
  contentGrouping: Maybe<ContentGrouping>
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupings: Maybe<ContentGroupingsConnection>
  contentItem: Maybe<ContentItem>
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: Maybe<ContentItemsConnection>
  contribution: Maybe<Contribution>
  /** Reads and enables pagination through a set of `Contribution`. */
  contributions: Maybe<ContributionsConnection>
  dataSource: Maybe<DataSource>
  /** Reads and enables pagination through a set of `DataSource`. */
  dataSources: Maybe<DataSourcesConnection>
  file: Maybe<File>
  /** Reads and enables pagination through a set of `File`. */
  files: Maybe<FilesConnection>
  license: Maybe<License>
  /** Reads and enables pagination through a set of `License`. */
  licenses: Maybe<LicensesConnection>
  mediaAsset: Maybe<MediaAsset>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: Maybe<MediaAssetsConnection>
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query
  revision: Maybe<Revision>
  /** Reads and enables pagination through a set of `Revision`. */
  revisions: Maybe<RevisionsConnection>
  transcript: Maybe<Transcript>
  /** Reads and enables pagination through a set of `Transcript`. */
  transcripts: Maybe<TranscriptsConnection>
}

/** The root query type which gives access points into the data universe. */
export type QueryActorArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryActorsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ActorCondition>
  filter: InputMaybe<ActorFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ActorsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryBroadcastEventArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryBroadcastEventsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastEventCondition>
  filter: InputMaybe<BroadcastEventFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryBroadcastServiceArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryBroadcastServicesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastServiceCondition>
  filter: InputMaybe<BroadcastServiceFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastServicesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryChapterArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryChaptersArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ChapterCondition>
  filter: InputMaybe<ChapterFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ChaptersOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryConceptArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryConceptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryContentGroupingArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryContentGroupingsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentGroupingCondition>
  filter: InputMaybe<ContentGroupingFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryContentItemArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryContributionArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryContributionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributionCondition>
  filter: InputMaybe<ContributionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributionsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryDataSourceArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryDataSourcesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<DataSourceCondition>
  filter: InputMaybe<DataSourceFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<DataSourcesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryFileArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryFilesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryLicenseArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryLicensesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryMediaAssetArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryRevisionArgs = {
  rowId: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryRevisionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<RevisionCondition>
  filter: InputMaybe<RevisionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<RevisionsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export type QueryTranscriptArgs = {
  uid: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryTranscriptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<TranscriptCondition>
  filter: InputMaybe<TranscriptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<TranscriptsOrderBy>>
}

export type Revision = {
  /** Reads and enables pagination through a set of `Actor`. */
  actors: ActorsConnection
  /** Reads and enables pagination through a set of `Actor`. */
  actorsByBroadcastServiceRevisionIdAndPublisherUid: RevisionActorsByBroadcastServiceRevisionIdAndPublisherUidManyToManyConnection
  alternativeIds: Maybe<Array<Maybe<Scalars['String']>>>
  /** Reads and enables pagination through a set of `BroadcastEvent`. */
  broadcastEvents: BroadcastEventsConnection
  /** Reads and enables pagination through a set of `BroadcastService`. */
  broadcastServices: BroadcastServicesConnection
  /** Reads and enables pagination through a set of `BroadcastService`. */
  broadcastServicesByBroadcastEventRevisionIdAndBroadcastServiceUid: RevisionBroadcastServicesByBroadcastEventRevisionIdAndBroadcastServiceUidManyToManyConnection
  /** Reads and enables pagination through a set of `Chapter`. */
  chapters: ChaptersConnection
  /** Reads and enables pagination through a set of `Concept`. */
  concepts: ConceptsConnection
  content: Scalars['JSON']
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupings: ContentGroupingsConnection
  /** Reads and enables pagination through a set of `ContentGrouping`. */
  contentGroupingsByContentItemRevisionIdAndPrimaryGroupingUid: RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidManyToManyConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItems: ContentItemsConnection
  /** Reads and enables pagination through a set of `ContentItem`. */
  contentItemsByBroadcastEventRevisionIdAndContentItemUid: RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidManyToManyConnection
  /** Reads and enables pagination through a set of `Contribution`. */
  contributions: ContributionsConnection
  created: Scalars['Datetime']
  datasource: Scalars['String']
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByActorRevisionIdAndProfilePictureUid: RevisionFilesByActorRevisionIdAndProfilePictureUidManyToManyConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetRevisionIdAndFileUid: RevisionFilesByMediaAssetRevisionIdAndFileUidManyToManyConnection
  /** Reads and enables pagination through a set of `File`. */
  filesByMediaAssetRevisionIdAndTeaserImageUid: RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidManyToManyConnection
  /** Reads and enables pagination through a set of `License`. */
  licenses: LicensesConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByContentGroupingRevisionIdAndLicenseUid: RevisionLicensesByContentGroupingRevisionIdAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByContentItemRevisionIdAndLicenseUid: RevisionLicensesByContentItemRevisionIdAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `License`. */
  licensesByMediaAssetRevisionIdAndLicenseUid: RevisionLicensesByMediaAssetRevisionIdAndLicenseUidManyToManyConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssetsByChapterRevisionIdAndMediaAssetUid: RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidManyToManyConnection
  /** Reads and enables pagination through a set of `Revision`. */
  nextRevisions: RevisionsConnection
  /** Reads a single `Revision` that is related to this `Revision`. */
  previousRevision: Maybe<Revision>
  previousRevisionId: Maybe<Scalars['String']>
  rowId: Scalars['String']
  type: Scalars['String']
  uid: Scalars['String']
}

export type RevisionActorsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ActorCondition>
  filter: InputMaybe<ActorFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ActorsOrderBy>>
}

export type RevisionActorsByBroadcastServiceRevisionIdAndPublisherUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ActorCondition>
  filter: InputMaybe<ActorFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ActorsOrderBy>>
}

export type RevisionBroadcastEventsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastEventCondition>
  filter: InputMaybe<BroadcastEventFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
}

export type RevisionBroadcastServicesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<BroadcastServiceCondition>
  filter: InputMaybe<BroadcastServiceFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<BroadcastServicesOrderBy>>
}

export type RevisionBroadcastServicesByBroadcastEventRevisionIdAndBroadcastServiceUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastServiceCondition>
    filter: InputMaybe<BroadcastServiceFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastServicesOrderBy>>
  }

export type RevisionChaptersArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ChapterCondition>
  filter: InputMaybe<ChapterFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ChaptersOrderBy>>
}

export type RevisionConceptsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ConceptCondition>
  filter: InputMaybe<ConceptFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ConceptsOrderBy>>
}

export type RevisionContentGroupingsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentGroupingCondition>
  filter: InputMaybe<ContentGroupingFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
}

export type RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentGroupingCondition>
    filter: InputMaybe<ContentGroupingFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
  }

export type RevisionContentItemsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContentItemCondition>
  filter: InputMaybe<ContentItemFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
}

export type RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

export type RevisionContributionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<ContributionCondition>
  filter: InputMaybe<ContributionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ContributionsOrderBy>>
}

export type RevisionFilesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type RevisionFilesByActorRevisionIdAndProfilePictureUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type RevisionFilesByMediaAssetRevisionIdAndFileUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<FileCondition>
  filter: InputMaybe<FileFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<FilesOrderBy>>
}

export type RevisionLicensesArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type RevisionLicensesByContentGroupingRevisionIdAndLicenseUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type RevisionLicensesByContentItemRevisionIdAndLicenseUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type RevisionLicensesByMediaAssetRevisionIdAndLicenseUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<LicenseCondition>
  filter: InputMaybe<LicenseFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LicensesOrderBy>>
}

export type RevisionMediaAssetsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

export type RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<MediaAssetCondition>
  filter: InputMaybe<MediaAssetFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
}

export type RevisionNextRevisionsArgs = {
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
  condition: InputMaybe<RevisionCondition>
  filter: InputMaybe<RevisionFilter>
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  offset: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<RevisionsOrderBy>>
}

/** A connection to a list of `Actor` values, with data from `BroadcastService`. */
export type RevisionActorsByBroadcastServiceRevisionIdAndPublisherUidManyToManyConnection =
  {
    /** A list of edges which contains the `Actor`, info from the `BroadcastService`, and the cursor to aid in pagination. */
    edges: Array<RevisionActorsByBroadcastServiceRevisionIdAndPublisherUidManyToManyEdge>
    /** A list of `Actor` objects. */
    nodes: Array<Actor>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `Actor` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `Actor` edge in the connection, with data from `BroadcastService`. */
export type RevisionActorsByBroadcastServiceRevisionIdAndPublisherUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `BroadcastService`. */
    broadcastServicesByPublisher: BroadcastServicesConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `Actor` at the end of the edge. */
    node: Actor
  }

/** A `Actor` edge in the connection, with data from `BroadcastService`. */
export type RevisionActorsByBroadcastServiceRevisionIdAndPublisherUidManyToManyEdgeBroadcastServicesByPublisherArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastServiceCondition>
    filter: InputMaybe<BroadcastServiceFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastServicesOrderBy>>
  }

/** A connection to a list of `BroadcastService` values, with data from `BroadcastEvent`. */
export type RevisionBroadcastServicesByBroadcastEventRevisionIdAndBroadcastServiceUidManyToManyConnection =
  {
    /** A list of edges which contains the `BroadcastService`, info from the `BroadcastEvent`, and the cursor to aid in pagination. */
    edges: Array<RevisionBroadcastServicesByBroadcastEventRevisionIdAndBroadcastServiceUidManyToManyEdge>
    /** A list of `BroadcastService` objects. */
    nodes: Array<BroadcastService>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `BroadcastService` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `BroadcastService` edge in the connection, with data from `BroadcastEvent`. */
export type RevisionBroadcastServicesByBroadcastEventRevisionIdAndBroadcastServiceUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `BroadcastEvent`. */
    broadcastEvents: BroadcastEventsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `BroadcastService` at the end of the edge. */
    node: BroadcastService
  }

/** A `BroadcastService` edge in the connection, with data from `BroadcastEvent`. */
export type RevisionBroadcastServicesByBroadcastEventRevisionIdAndBroadcastServiceUidManyToManyEdgeBroadcastEventsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastEventCondition>
    filter: InputMaybe<BroadcastEventFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
  }

/**
 * A condition to be used against `Revision` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RevisionCondition = {
  /** Checks for equality with the object’s `alternativeIds` field. */
  alternativeIds: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Checks for equality with the object’s `content` field. */
  content: InputMaybe<Scalars['JSON']>
  /** Checks for equality with the object’s `created` field. */
  created: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `datasource` field. */
  datasource: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `previousRevisionId` field. */
  previousRevisionId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `rowId` field. */
  rowId: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `type` field. */
  type: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ContentGrouping` values, with data from `ContentItem`. */
export type RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidManyToManyConnection =
  {
    /** A list of edges which contains the `ContentGrouping`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidManyToManyEdge>
    /** A list of `ContentGrouping` objects. */
    nodes: Array<ContentGrouping>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentGrouping` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentGrouping` edge in the connection, with data from `ContentItem`. */
export type RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItemsByPrimaryGrouping: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `ContentGrouping` at the end of the edge. */
    node: ContentGrouping
  }

/** A `ContentGrouping` edge in the connection, with data from `ContentItem`. */
export type RevisionContentGroupingsByContentItemRevisionIdAndPrimaryGroupingUidManyToManyEdgeContentItemsByPrimaryGroupingArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A connection to a list of `ContentItem` values, with data from `BroadcastEvent`. */
export type RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidManyToManyConnection =
  {
    /** A list of edges which contains the `ContentItem`, info from the `BroadcastEvent`, and the cursor to aid in pagination. */
    edges: Array<RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidManyToManyEdge>
    /** A list of `ContentItem` objects. */
    nodes: Array<ContentItem>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `ContentItem` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `ContentItem` edge in the connection, with data from `BroadcastEvent`. */
export type RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `BroadcastEvent`. */
    broadcastEvents: BroadcastEventsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `ContentItem` at the end of the edge. */
    node: ContentItem
  }

/** A `ContentItem` edge in the connection, with data from `BroadcastEvent`. */
export type RevisionContentItemsByBroadcastEventRevisionIdAndContentItemUidManyToManyEdgeBroadcastEventsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<BroadcastEventCondition>
    filter: InputMaybe<BroadcastEventFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<BroadcastEventsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `Actor`. */
export type RevisionFilesByActorRevisionIdAndProfilePictureUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `Actor`, and the cursor to aid in pagination. */
    edges: Array<RevisionFilesByActorRevisionIdAndProfilePictureUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `Actor`. */
export type RevisionFilesByActorRevisionIdAndProfilePictureUidManyToManyEdge = {
  /** Reads and enables pagination through a set of `Actor`. */
  actorsByProfilePicture: ActorsConnection
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `File` at the end of the edge. */
  node: File
}

/** A `File` edge in the connection, with data from `Actor`. */
export type RevisionFilesByActorRevisionIdAndProfilePictureUidManyToManyEdgeActorsByProfilePictureArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ActorCondition>
    filter: InputMaybe<ActorFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ActorsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndFileUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<RevisionFilesByMediaAssetRevisionIdAndFileUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndFileUidManyToManyEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** Reads and enables pagination through a set of `MediaAsset`. */
  mediaAssets: MediaAssetsConnection
  /** The `File` at the end of the edge. */
  node: File
}

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndFileUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `File` values, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidManyToManyConnection =
  {
    /** A list of edges which contains the `File`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidManyToManyEdge>
    /** A list of `File` objects. */
    nodes: Array<File>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `File` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidManyToManyEdge =
  {
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** Reads and enables pagination through a set of `MediaAsset`. */
    mediaAssetsByTeaserImage: MediaAssetsConnection
    /** The `File` at the end of the edge. */
    node: File
  }

/** A `File` edge in the connection, with data from `MediaAsset`. */
export type RevisionFilesByMediaAssetRevisionIdAndTeaserImageUidManyToManyEdgeMediaAssetsByTeaserImageArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A filter to be used against `Revision` object types. All fields are combined with a logical ‘and.’ */
export type RevisionFilter = {
  /** Filter by the object’s `alternativeIds` field. */
  alternativeIds: InputMaybe<StringListFilter>
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<RevisionFilter>>
  /** Filter by the object’s `content` field. */
  content: InputMaybe<JsonFilter>
  /** Filter by the object’s `created` field. */
  created: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `datasource` field. */
  datasource: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<RevisionFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<RevisionFilter>>
  /** Filter by the object’s `previousRevisionId` field. */
  previousRevisionId: InputMaybe<StringFilter>
  /** Filter by the object’s `rowId` field. */
  rowId: InputMaybe<StringFilter>
  /** Filter by the object’s `type` field. */
  type: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `License` values, with data from `ContentGrouping`. */
export type RevisionLicensesByContentGroupingRevisionIdAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `ContentGrouping`, and the cursor to aid in pagination. */
    edges: Array<RevisionLicensesByContentGroupingRevisionIdAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `ContentGrouping`. */
export type RevisionLicensesByContentGroupingRevisionIdAndLicenseUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentGrouping`. */
    contentGroupings: ContentGroupingsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `ContentGrouping`. */
export type RevisionLicensesByContentGroupingRevisionIdAndLicenseUidManyToManyEdgeContentGroupingsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentGroupingCondition>
    filter: InputMaybe<ContentGroupingFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentGroupingsOrderBy>>
  }

/** A connection to a list of `License` values, with data from `ContentItem`. */
export type RevisionLicensesByContentItemRevisionIdAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `ContentItem`, and the cursor to aid in pagination. */
    edges: Array<RevisionLicensesByContentItemRevisionIdAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `ContentItem`. */
export type RevisionLicensesByContentItemRevisionIdAndLicenseUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `ContentItem`. */
    contentItems: ContentItemsConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `ContentItem`. */
export type RevisionLicensesByContentItemRevisionIdAndLicenseUidManyToManyEdgeContentItemsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ContentItemCondition>
    filter: InputMaybe<ContentItemFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ContentItemsOrderBy>>
  }

/** A connection to a list of `License` values, with data from `MediaAsset`. */
export type RevisionLicensesByMediaAssetRevisionIdAndLicenseUidManyToManyConnection =
  {
    /** A list of edges which contains the `License`, info from the `MediaAsset`, and the cursor to aid in pagination. */
    edges: Array<RevisionLicensesByMediaAssetRevisionIdAndLicenseUidManyToManyEdge>
    /** A list of `License` objects. */
    nodes: Array<License>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `License` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type RevisionLicensesByMediaAssetRevisionIdAndLicenseUidManyToManyEdge =
  {
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** Reads and enables pagination through a set of `MediaAsset`. */
    mediaAssets: MediaAssetsConnection
    /** The `License` at the end of the edge. */
    node: License
  }

/** A `License` edge in the connection, with data from `MediaAsset`. */
export type RevisionLicensesByMediaAssetRevisionIdAndLicenseUidManyToManyEdgeMediaAssetsArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<MediaAssetCondition>
    filter: InputMaybe<MediaAssetFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<MediaAssetsOrderBy>>
  }

/** A connection to a list of `MediaAsset` values, with data from `Chapter`. */
export type RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidManyToManyConnection =
  {
    /** A list of edges which contains the `MediaAsset`, info from the `Chapter`, and the cursor to aid in pagination. */
    edges: Array<RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidManyToManyEdge>
    /** A list of `MediaAsset` objects. */
    nodes: Array<MediaAsset>
    /** Information to aid in pagination. */
    pageInfo: PageInfo
    /** The count of *all* `MediaAsset` you could get from the connection. */
    totalCount: Scalars['Int']
  }

/** A `MediaAsset` edge in the connection, with data from `Chapter`. */
export type RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidManyToManyEdge =
  {
    /** Reads and enables pagination through a set of `Chapter`. */
    chapters: ChaptersConnection
    /** A cursor for use in pagination. */
    cursor: Maybe<Scalars['Cursor']>
    /** The `MediaAsset` at the end of the edge. */
    node: MediaAsset
  }

/** A `MediaAsset` edge in the connection, with data from `Chapter`. */
export type RevisionMediaAssetsByChapterRevisionIdAndMediaAssetUidManyToManyEdgeChaptersArgs =
  {
    after: InputMaybe<Scalars['Cursor']>
    before: InputMaybe<Scalars['Cursor']>
    condition: InputMaybe<ChapterCondition>
    filter: InputMaybe<ChapterFilter>
    first: InputMaybe<Scalars['Int']>
    last: InputMaybe<Scalars['Int']>
    offset: InputMaybe<Scalars['Int']>
    orderBy?: InputMaybe<Array<ChaptersOrderBy>>
  }

/** A connection to a list of `Revision` values. */
export type RevisionsConnection = {
  /** A list of edges which contains the `Revision` and cursor to aid in pagination. */
  edges: Array<RevisionsEdge>
  /** A list of `Revision` objects. */
  nodes: Array<Revision>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Revision` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Revision` edge in the connection. */
export type RevisionsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `Revision` at the end of the edge. */
  node: Revision
}

/** Methods to use when ordering `Revision`. */
export enum RevisionsOrderBy {
  AlternativeIdsAsc = 'ALTERNATIVE_IDS_ASC',
  AlternativeIdsDesc = 'ALTERNATIVE_IDS_DESC',
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DatasourceAsc = 'DATASOURCE_ASC',
  DatasourceDesc = 'DATASOURCE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PreviousRevisionIdAsc = 'PREVIOUS_REVISION_ID_ASC',
  PreviousRevisionIdDesc = 'PREVIOUS_REVISION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom: InputMaybe<Scalars['String']>
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive: InputMaybe<Scalars['String']>
  /** Ends with the specified string (case-sensitive). */
  endsWith: InputMaybe<Scalars['String']>
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive: InputMaybe<Scalars['String']>
  /** Equal to the specified value. */
  equalTo: InputMaybe<Scalars['String']>
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive: InputMaybe<Scalars['String']>
  /** Greater than the specified value. */
  greaterThan: InputMaybe<Scalars['String']>
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive: InputMaybe<Scalars['String']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo: InputMaybe<Scalars['String']>
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive: InputMaybe<Scalars['String']>
  /** Included in the specified list. */
  in: InputMaybe<Array<Scalars['String']>>
  /** Included in the specified list (case-insensitive). */
  inInsensitive: InputMaybe<Array<Scalars['String']>>
  /** Contains the specified string (case-sensitive). */
  includes: InputMaybe<Scalars['String']>
  /** Contains the specified string (case-insensitive). */
  includesInsensitive: InputMaybe<Scalars['String']>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan: InputMaybe<Scalars['String']>
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive: InputMaybe<Scalars['String']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo: InputMaybe<Scalars['String']>
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive: InputMaybe<Scalars['String']>
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like: InputMaybe<Scalars['String']>
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive: InputMaybe<Scalars['String']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom: InputMaybe<Scalars['String']>
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive: InputMaybe<Scalars['String']>
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith: InputMaybe<Scalars['String']>
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive: InputMaybe<Scalars['String']>
  /** Not equal to the specified value. */
  notEqualTo: InputMaybe<Scalars['String']>
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive: InputMaybe<Scalars['String']>
  /** Not included in the specified list. */
  notIn: InputMaybe<Array<Scalars['String']>>
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive: InputMaybe<Array<Scalars['String']>>
  /** Does not contain the specified string (case-sensitive). */
  notIncludes: InputMaybe<Scalars['String']>
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive: InputMaybe<Scalars['String']>
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike: InputMaybe<Scalars['String']>
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive: InputMaybe<Scalars['String']>
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith: InputMaybe<Scalars['String']>
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive: InputMaybe<Scalars['String']>
  /** Starts with the specified string (case-sensitive). */
  startsWith: InputMaybe<Scalars['String']>
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive: InputMaybe<Scalars['String']>
}

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo: InputMaybe<Scalars['String']>
  /** Any array item is greater than the specified value. */
  anyGreaterThan: InputMaybe<Scalars['String']>
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo: InputMaybe<Scalars['String']>
  /** Any array item is less than the specified value. */
  anyLessThan: InputMaybe<Scalars['String']>
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo: InputMaybe<Scalars['String']>
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo: InputMaybe<Scalars['String']>
  /** Contained by the specified list of values. */
  containedBy: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Contains the specified list of values. */
  contains: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Equal to the specified value. */
  equalTo: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Greater than the specified value. */
  greaterThan: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Not equal to the specified value. */
  notEqualTo: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  /** Overlaps the specified list of values. */
  overlaps: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Transcript = {
  engine: Scalars['String']
  language: Scalars['String']
  /** Reads a single `MediaAsset` that is related to this `Transcript`. */
  mediaAsset: Maybe<MediaAsset>
  mediaAssetUid: Scalars['String']
  text: Scalars['String']
  uid: Scalars['String']
}

/**
 * A condition to be used against `Transcript` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TranscriptCondition = {
  /** Checks for equality with the object’s `engine` field. */
  engine: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `language` field. */
  language: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `mediaAssetUid` field. */
  mediaAssetUid: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `text` field. */
  text: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `uid` field. */
  uid: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Transcript` object types. All fields are combined with a logical ‘and.’ */
export type TranscriptFilter = {
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<TranscriptFilter>>
  /** Filter by the object’s `engine` field. */
  engine: InputMaybe<StringFilter>
  /** Filter by the object’s `language` field. */
  language: InputMaybe<StringFilter>
  /** Filter by the object’s `mediaAssetUid` field. */
  mediaAssetUid: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<TranscriptFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<TranscriptFilter>>
  /** Filter by the object’s `text` field. */
  text: InputMaybe<StringFilter>
  /** Filter by the object’s `uid` field. */
  uid: InputMaybe<StringFilter>
}

/** A connection to a list of `Transcript` values. */
export type TranscriptsConnection = {
  /** A list of edges which contains the `Transcript` and cursor to aid in pagination. */
  edges: Array<TranscriptsEdge>
  /** A list of `Transcript` objects. */
  nodes: Array<Transcript>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Transcript` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Transcript` edge in the connection. */
export type TranscriptsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `Transcript` at the end of the edge. */
  node: Transcript
}

/** Methods to use when ordering `Transcript`. */
export enum TranscriptsOrderBy {
  EngineAsc = 'ENGINE_ASC',
  EngineDesc = 'ENGINE_DESC',
  LanguageAsc = 'LANGUAGE_ASC',
  LanguageDesc = 'LANGUAGE_DESC',
  MediaAssetUidAsc = 'MEDIA_ASSET_UID_ASC',
  MediaAssetUidDesc = 'MEDIA_ASSET_UID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TextAsc = 'TEXT_ASC',
  TextDesc = 'TEXT_DESC',
  UidAsc = 'UID_ASC',
  UidDesc = 'UID_DESC',
}

export type _ActorToContribution = {
  a: Scalars['String']
  /** Reads a single `Actor` that is related to this `_ActorToContribution`. */
  actorByA: Maybe<Actor>
  b: Scalars['String']
  /** Reads a single `Contribution` that is related to this `_ActorToContribution`. */
  contributionByB: Maybe<Contribution>
}

/**
 * A condition to be used against `_ActorToContribution` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type _ActorToContributionCondition = {
  /** Checks for equality with the object’s `a` field. */
  a: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ActorToContribution` object types. All fields are combined with a logical ‘and.’ */
export type _ActorToContributionFilter = {
  /** Filter by the object’s `a` field. */
  a: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<_ActorToContributionFilter>>
  /** Filter by the object’s `b` field. */
  b: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<_ActorToContributionFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<_ActorToContributionFilter>>
}

/** A connection to a list of `_ActorToContribution` values. */
export type _ActorToContributionsConnection = {
  /** A list of edges which contains the `_ActorToContribution` and cursor to aid in pagination. */
  edges: Array<_ActorToContributionsEdge>
  /** A list of `_ActorToContribution` objects. */
  nodes: Array<_ActorToContribution>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ActorToContribution` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ActorToContribution` edge in the connection. */
export type _ActorToContributionsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `_ActorToContribution` at the end of the edge. */
  node: _ActorToContribution
}

/** Methods to use when ordering `_ActorToContribution`. */
export enum _ActorToContributionsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ConceptToContentItem = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `Concept` that is related to this `_ConceptToContentItem`. */
  conceptByA: Maybe<Concept>
  /** Reads a single `ContentItem` that is related to this `_ConceptToContentItem`. */
  contentItemByB: Maybe<ContentItem>
}

/**
 * A condition to be used against `_ConceptToContentItem` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type _ConceptToContentItemCondition = {
  /** Checks for equality with the object’s `a` field. */
  a: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ConceptToContentItem` object types. All fields are combined with a logical ‘and.’ */
export type _ConceptToContentItemFilter = {
  /** Filter by the object’s `a` field. */
  a: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<_ConceptToContentItemFilter>>
  /** Filter by the object’s `b` field. */
  b: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<_ConceptToContentItemFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<_ConceptToContentItemFilter>>
}

/** A connection to a list of `_ConceptToContentItem` values. */
export type _ConceptToContentItemsConnection = {
  /** A list of edges which contains the `_ConceptToContentItem` and cursor to aid in pagination. */
  edges: Array<_ConceptToContentItemsEdge>
  /** A list of `_ConceptToContentItem` objects. */
  nodes: Array<_ConceptToContentItem>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ConceptToContentItem` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ConceptToContentItem` edge in the connection. */
export type _ConceptToContentItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `_ConceptToContentItem` at the end of the edge. */
  node: _ConceptToContentItem
}

/** Methods to use when ordering `_ConceptToContentItem`. */
export enum _ConceptToContentItemsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ConceptToMediaAsset = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `Concept` that is related to this `_ConceptToMediaAsset`. */
  conceptByA: Maybe<Concept>
  /** Reads a single `MediaAsset` that is related to this `_ConceptToMediaAsset`. */
  mediaAssetByB: Maybe<MediaAsset>
}

/**
 * A condition to be used against `_ConceptToMediaAsset` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type _ConceptToMediaAssetCondition = {
  /** Checks for equality with the object’s `a` field. */
  a: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ConceptToMediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type _ConceptToMediaAssetFilter = {
  /** Filter by the object’s `a` field. */
  a: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<_ConceptToMediaAssetFilter>>
  /** Filter by the object’s `b` field. */
  b: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<_ConceptToMediaAssetFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<_ConceptToMediaAssetFilter>>
}

/** A connection to a list of `_ConceptToMediaAsset` values. */
export type _ConceptToMediaAssetsConnection = {
  /** A list of edges which contains the `_ConceptToMediaAsset` and cursor to aid in pagination. */
  edges: Array<_ConceptToMediaAssetsEdge>
  /** A list of `_ConceptToMediaAsset` objects. */
  nodes: Array<_ConceptToMediaAsset>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ConceptToMediaAsset` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ConceptToMediaAsset` edge in the connection. */
export type _ConceptToMediaAssetsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `_ConceptToMediaAsset` at the end of the edge. */
  node: _ConceptToMediaAsset
}

/** Methods to use when ordering `_ConceptToMediaAsset`. */
export enum _ConceptToMediaAssetsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ContentGroupingToContentItem = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `ContentGrouping` that is related to this `_ContentGroupingToContentItem`. */
  contentGroupingByA: Maybe<ContentGrouping>
  /** Reads a single `ContentItem` that is related to this `_ContentGroupingToContentItem`. */
  contentItemByB: Maybe<ContentItem>
}

/**
 * A condition to be used against `_ContentGroupingToContentItem` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type _ContentGroupingToContentItemCondition = {
  /** Checks for equality with the object’s `a` field. */
  a: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ContentGroupingToContentItem` object types. All fields are combined with a logical ‘and.’ */
export type _ContentGroupingToContentItemFilter = {
  /** Filter by the object’s `a` field. */
  a: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<_ContentGroupingToContentItemFilter>>
  /** Filter by the object’s `b` field. */
  b: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<_ContentGroupingToContentItemFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<_ContentGroupingToContentItemFilter>>
}

/** A connection to a list of `_ContentGroupingToContentItem` values. */
export type _ContentGroupingToContentItemsConnection = {
  /** A list of edges which contains the `_ContentGroupingToContentItem` and cursor to aid in pagination. */
  edges: Array<_ContentGroupingToContentItemsEdge>
  /** A list of `_ContentGroupingToContentItem` objects. */
  nodes: Array<_ContentGroupingToContentItem>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ContentGroupingToContentItem` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ContentGroupingToContentItem` edge in the connection. */
export type _ContentGroupingToContentItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `_ContentGroupingToContentItem` at the end of the edge. */
  node: _ContentGroupingToContentItem
}

/** Methods to use when ordering `_ContentGroupingToContentItem`. */
export enum _ContentGroupingToContentItemsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ContentItemToContribution = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `ContentItem` that is related to this `_ContentItemToContribution`. */
  contentItemByA: Maybe<ContentItem>
  /** Reads a single `Contribution` that is related to this `_ContentItemToContribution`. */
  contributionByB: Maybe<Contribution>
}

/**
 * A condition to be used against `_ContentItemToContribution` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type _ContentItemToContributionCondition = {
  /** Checks for equality with the object’s `a` field. */
  a: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ContentItemToContribution` object types. All fields are combined with a logical ‘and.’ */
export type _ContentItemToContributionFilter = {
  /** Filter by the object’s `a` field. */
  a: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<_ContentItemToContributionFilter>>
  /** Filter by the object’s `b` field. */
  b: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<_ContentItemToContributionFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<_ContentItemToContributionFilter>>
}

/** A connection to a list of `_ContentItemToContribution` values. */
export type _ContentItemToContributionsConnection = {
  /** A list of edges which contains the `_ContentItemToContribution` and cursor to aid in pagination. */
  edges: Array<_ContentItemToContributionsEdge>
  /** A list of `_ContentItemToContribution` objects. */
  nodes: Array<_ContentItemToContribution>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ContentItemToContribution` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ContentItemToContribution` edge in the connection. */
export type _ContentItemToContributionsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `_ContentItemToContribution` at the end of the edge. */
  node: _ContentItemToContribution
}

/** Methods to use when ordering `_ContentItemToContribution`. */
export enum _ContentItemToContributionsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ContentItemToMediaAsset = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `ContentItem` that is related to this `_ContentItemToMediaAsset`. */
  contentItemByA: Maybe<ContentItem>
  /** Reads a single `MediaAsset` that is related to this `_ContentItemToMediaAsset`. */
  mediaAssetByB: Maybe<MediaAsset>
}

/**
 * A condition to be used against `_ContentItemToMediaAsset` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type _ContentItemToMediaAssetCondition = {
  /** Checks for equality with the object’s `a` field. */
  a: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ContentItemToMediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type _ContentItemToMediaAssetFilter = {
  /** Filter by the object’s `a` field. */
  a: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<_ContentItemToMediaAssetFilter>>
  /** Filter by the object’s `b` field. */
  b: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<_ContentItemToMediaAssetFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<_ContentItemToMediaAssetFilter>>
}

/** A connection to a list of `_ContentItemToMediaAsset` values. */
export type _ContentItemToMediaAssetsConnection = {
  /** A list of edges which contains the `_ContentItemToMediaAsset` and cursor to aid in pagination. */
  edges: Array<_ContentItemToMediaAssetsEdge>
  /** A list of `_ContentItemToMediaAsset` objects. */
  nodes: Array<_ContentItemToMediaAsset>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ContentItemToMediaAsset` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ContentItemToMediaAsset` edge in the connection. */
export type _ContentItemToMediaAssetsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `_ContentItemToMediaAsset` at the end of the edge. */
  node: _ContentItemToMediaAsset
}

/** Methods to use when ordering `_ContentItemToMediaAsset`. */
export enum _ContentItemToMediaAssetsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type _ContributionToMediaAsset = {
  a: Scalars['String']
  b: Scalars['String']
  /** Reads a single `Contribution` that is related to this `_ContributionToMediaAsset`. */
  contributionByA: Maybe<Contribution>
  /** Reads a single `MediaAsset` that is related to this `_ContributionToMediaAsset`. */
  mediaAssetByB: Maybe<MediaAsset>
}

/**
 * A condition to be used against `_ContributionToMediaAsset` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type _ContributionToMediaAssetCondition = {
  /** Checks for equality with the object’s `a` field. */
  a: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `b` field. */
  b: InputMaybe<Scalars['String']>
}

/** A filter to be used against `_ContributionToMediaAsset` object types. All fields are combined with a logical ‘and.’ */
export type _ContributionToMediaAssetFilter = {
  /** Filter by the object’s `a` field. */
  a: InputMaybe<StringFilter>
  /** Checks for all expressions in this list. */
  and: InputMaybe<Array<_ContributionToMediaAssetFilter>>
  /** Filter by the object’s `b` field. */
  b: InputMaybe<StringFilter>
  /** Negates the expression. */
  not: InputMaybe<_ContributionToMediaAssetFilter>
  /** Checks for any expressions in this list. */
  or: InputMaybe<Array<_ContributionToMediaAssetFilter>>
}

/** A connection to a list of `_ContributionToMediaAsset` values. */
export type _ContributionToMediaAssetsConnection = {
  /** A list of edges which contains the `_ContributionToMediaAsset` and cursor to aid in pagination. */
  edges: Array<_ContributionToMediaAssetsEdge>
  /** A list of `_ContributionToMediaAsset` objects. */
  nodes: Array<_ContributionToMediaAsset>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `_ContributionToMediaAsset` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `_ContributionToMediaAsset` edge in the connection. */
export type _ContributionToMediaAssetsEdge = {
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>
  /** The `_ContributionToMediaAsset` at the end of the edge. */
  node: _ContributionToMediaAsset
}

/** Methods to use when ordering `_ContributionToMediaAsset`. */
export enum _ContributionToMediaAssetsOrderBy {
  AAsc = 'A_ASC',
  ADesc = 'A_DESC',
  BAsc = 'B_ASC',
  BDesc = 'B_DESC',
  Natural = 'NATURAL',
}

export type LoadContentItemQueryVariables = Exact<{
  uid: Scalars['String']
}>

export type LoadContentItemQuery = {
  contentItem: {
    title: string
    uid: string
    content: string
    revisionId: string
    mediaAssets: {
      nodes: Array<{
        uid: string
        mediaType: string
        file: { uid: string; contentUrl: string } | null
      }>
    }
  } | null
}

export type LoadContentItemsQueryVariables = Exact<{
  first: InputMaybe<Scalars['Int']>
  last: InputMaybe<Scalars['Int']>
  after: InputMaybe<Scalars['Cursor']>
  before: InputMaybe<Scalars['Cursor']>
}>

export type LoadContentItemsQuery = {
  contentItems: {
    pageInfo: {
      startCursor: string | null
      endCursor: string | null
      hasNextPage: boolean
      hasPreviousPage: boolean
    }
    nodes: Array<{ title: string; uid: string; summary: string | null }>
  } | null
}
